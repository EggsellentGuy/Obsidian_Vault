# Введение 
Функции мощный инструмент в python, их бывает много видов и они могут принимать различное количество аргументов. Так же бывают анонимные функции, которые сильно расширяют функционал языка. 

## Переменное количество аргументов

Переменное количество аргументов может принимать функция с помощью символа `*`, выглядит это примерно `*args`. 
Аргументы автоматически упаковываются в кортеж 
```python
def f(x, *args):
    print(f'Первый аргумент: {x}')
    for a in args:
        print(f'Другой аргумент из *args {a}!')

f('Programming language', 'Python', 'PHP', 'Java')
# => Первый аргумент: Programming language
# => Другой аргумент из *args Python!
# => Другой аргумент из *args PHP!
# => Другой аргумент из *args Java!

f()
# TypeError: f() missing 1 required positional argument: 'x'
```

Здесь функция принимает несколько аргументов, но как минимум один должен быть передан всегда. Первый аргумент станет значением переменной x, а остальные сохранятся в *args. Так можно делать любое нужное количество обязательных аргументов.

## Передача аргументов в форме коллекции

Иногда нужно сначала сформировать набор аргументов, а потом передать их функции. Допустим, прочитать параметры из файла или получить другим программным способом. Здесь снова пригодится оператор `*`:
```python
def sum(a, b):
    return a + b

nums = [3, 4]
sum(*nums) # 7
```
Часть аргументов можно подставлять сразу в функцию и даже подставлять несколько коллекций сразу:
```python
def greet(*names):
    for name in names:
        print(f'Hello, {name}!')

greet(
   'Bob', *['Mary', 'Clair'], 'Sam',
   *('Henry', 'John')
)
# => Hello, Bob!
# => Hello, Mary!
# => Hello, Clair!
# => Hello, Sam!
# => Hello, Henry!
# => Hello, John!
```
В приведенном примере мы передали в функцию greet набор одиночных аргументов и коллекций. При помощи оператора * функция greet вызывается с шестью аргументами: 'Bob', 'Mary', 'Clair', 'Sam', 'Henry' и 'John'. Результатом этого кода будет шесть приветствий по одному для каждого аргумента. Они будут в том порядке, в котором их передали в функцию.

# Именованные параметры

При вызове функции с позиционными параметрами важную роль играет порядок размещения передаваемых аргументов.

```python
def bar(length, char1, char2):
    return (char1 + char2) * length + char1

print(bar(5, '-', '*'))
# => -*-*-*-*-*-
```

## Именованный аргументы

Чтобы передать именованные аргументы в функцию, нужно указать их имена, которые были заданы при объявлении функции:
```python
def bar(length, char1, char2):
    return (char1 + char2) * length + char1

print(bar(length=3, char1='-', char2='*'))
# => -*-*-*-
print(bar(char1='-', char2='*', length=3))
# => -*-*-*-
print(bar(char2='*', length=3, char1='-'))
# => -*-*-*-
```

При обращении к параметрам функции таким образом ключевую роль играет имя параметра, а не его позиция.

## Значения параметров по умолчанию

Можно задать параметры по умолчанию и в случаи, если значение не передано в функцию, то будет использоваться значение по умолчанию.
```python 
def bar(length, char1='-', char2='*'):
    return (char1 + char2) * length + char1

print(bar(5))
# => -*-*-*-*-*-
print(bar(3, '.'))
# => .*.*.*.
print(bar(2, ':', '|'))
# => :|:|:
```

здесь имеет значение порядок групп аргументов — позиционные значения должны быть указаны до именованных. Иначе мы получим ошибку:

```python
print(bar(char2='%', 2))
# => SyntaxError: positional argument follows keyword argument
```

Если у функции есть позиционные параметры без значений по умолчанию, значения для этих параметров все равно нужно указать либо в виде позиционных значений, либо в виде именованных. Нарушение этого правила приведет к ошибке вида:

```python 
bar(char2='!')
# TypeError: bar() missing 1 required positional argument: 'length'
```

Нужно различать синтаксис объявления параметров функции и синтаксис вызова функции. При вызове функции у нас больше свободы. Например, можно указывать именованные параметры перед разворачиваемой группой позиционных:

```python
def f(*args, x=None, y=None):
    print('args =', args, ', x =', x, ', y =', y)

f(*(1, 2), x='a', *[3, 4], y='b', *(5, 6))
# => args = (1, 2, 3, 4, 5, 6), x = a, y = b
```







