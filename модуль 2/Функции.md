# Введение 
Функции мощный инструмент в python, их бывает много видов и они могут принимать различное количество аргументов. Так же бывают анонимные функции, которые сильно расширяют функционал языка. 

## Переменное количество аргументов

Переменное количество аргументов может принимать функция с помощью символа `*`, выглядит это примерно `*args`. 
Аргументы автоматически упаковываются в кортеж 
```python
def f(x, *args):
    print(f'Первый аргумент: {x}')
    for a in args:
        print(f'Другой аргумент из *args {a}!')

f('Programming language', 'Python', 'PHP', 'Java')
# => Первый аргумент: Programming language
# => Другой аргумент из *args Python!
# => Другой аргумент из *args PHP!
# => Другой аргумент из *args Java!

f()
# TypeError: f() missing 1 required positional argument: 'x'
```

Здесь функция принимает несколько аргументов, но как минимум один должен быть передан всегда. Первый аргумент станет значением переменной x, а остальные сохранятся в *args. Так можно делать любое нужное количество обязательных аргументов.

## Передача аргументов в форме коллекции

Иногда нужно сначала сформировать набор аргументов, а потом передать их функции. Допустим, прочитать параметры из файла или получить другим программным способом. Здесь снова пригодится оператор `*`:
```python
def sum(a, b):
    return a + b

nums = [3, 4]
sum(*nums) # 7
```
Часть аргументов можно подставлять сразу в функцию и даже подставлять несколько коллекций сразу:
```python
def greet(*names):
    for name in names:
        print(f'Hello, {name}!')

greet(
   'Bob', *['Mary', 'Clair'], 'Sam',
   *('Henry', 'John')
)
# => Hello, Bob!
# => Hello, Mary!
# => Hello, Clair!
# => Hello, Sam!
# => Hello, Henry!
# => Hello, John!
```
В приведенном примере мы передали в функцию greet набор одиночных аргументов и коллекций. При помощи оператора * функция greet вызывается с шестью аргументами: 'Bob', 'Mary', 'Clair', 'Sam', 'Henry' и 'John'. Результатом этого кода будет шесть приветствий по одному для каждого аргумента. Они будут в том порядке, в котором их передали в функцию.

# Именованные параметры

При вызове функции с позиционными параметрами важную роль играет порядок размещения передаваемых аргументов.

```python
def bar(length, char1, char2):
    return (char1 + char2) * length + char1

print(bar(5, '-', '*'))
# => -*-*-*-*-*-
```

## Именованный аргументы

Чтобы передать именованные аргументы в функцию, нужно указать их имена, которые были заданы при объявлении функции:
```python
def bar(length, char1, char2):
    return (char1 + char2) * length + char1

print(bar(length=3, char1='-', char2='*'))
# => -*-*-*-
print(bar(char1='-', char2='*', length=3))
# => -*-*-*-
print(bar(char2='*', length=3, char1='-'))
# => -*-*-*-
```

При обращении к параметрам функции таким образом ключевую роль играет имя параметра, а не его позиция.

## Значения параметров по умолчанию

Можно задать параметры по умолчанию и в случаи, если значение не передано в функцию, то будет использоваться значение по умолчанию.
```python 
def bar(length, char1='-', char2='*'):
    return (char1 + char2) * length + char1

print(bar(5))
# => -*-*-*-*-*-
print(bar(3, '.'))
# => .*.*.*.
print(bar(2, ':', '|'))
# => :|:|:
```

здесь имеет значение порядок групп аргументов — позиционные значения должны быть указаны до именованных. Иначе мы получим ошибку:

```python
print(bar(char2='%', 2))
# => SyntaxError: positional argument follows keyword argument
```

Если у функции есть позиционные параметры без значений по умолчанию, значения для этих параметров все равно нужно указать либо в виде позиционных значений, либо в виде именованных. Нарушение этого правила приведет к ошибке вида:

```python 
bar(char2='!')
# TypeError: bar() missing 1 required positional argument: 'length'
```

Нужно различать синтаксис объявления параметров функции и синтаксис вызова функции. При вызове функции у нас больше свободы. Например, можно указывать именованные параметры перед разворачиваемой группой позиционных:

```python
def f(*args, x=None, y=None):
    print('args =', args, ', x =', x, ', y =', y)

f(*(1, 2), x='a', *[3, 4], y='b', *(5, 6))
# => args = (1, 2, 3, 4, 5, 6), x = a, y = b
```


# Порядок параметров в функции

1. Обычные позиционные параметры
2. Параметр `*args`
3. Параметры со значением по умолчанию
4. Параметр `**kwargs`


## Передача именованных аргументов с помощью словаря

аргументы в функцию можно передавать через словарь, для этого нужно поставить `**` перед аргументом.

```python
def coords(x, y):
    return (x, y)

coords(x=1, **{'y': 2})
# (1, 2)
```
Или более сложный пример:

```python
def f(x, y, *args, kx=None, ky=42, **kwargs):
    return (x, y, args, kx, ky, kwargs)

positional = (2, 3)
named = dict(ky='b', kz='c')
f(1, *positional, 4, kx='a', **named)
# (1, 2, (3, 4), 'a', 'b', {'kz': 'c'})
```

В этом примере мы создали словарь функцией `dict` с несколькими именованными аргументами. Так словарь еще больше похож на сохраненный набор аргументов.

При подстановке аргументов разворачивающиеся наборы аргументов вроде `*positional` и `**named` можно указывать вперемешку с аргументами соответствующего типа: `*positional` — с позиционными, `**named` — с именованными. При этом все именованные аргументы должны идти после всех позиционных.


## Keyword-only аргументы

```python 
def open_file(name, *, writable=False, binary=False):
    …

f1 = open_file('foo.txt', writable=True)
f2 = open_file('bar.bin', binary=True)
f3 = open_file('raw.dat', True, True)
# TypeError: open_file() takes 1 positional argument but 3 were given
```

Здесь `*` выступает разделителем — отделяет обычные параметры от строго именованных. Такой разделитель можно использовать только один раз в одном определении. Еще его нельзя применять в функциях с `*args`. Но можно объявлять функции, у которых будут только строго именованные аргументы. Для этого нужно поставить звездочку в самом начале перечня аргументов.

Когда мы используем `keyword-only` аргументы вместе с именованными аргументами (`**kwargs`), возникает проблема. Именованные аргументы могут перехватить значения, которые должны были быть переданы как `keyword-only` аргументы. В итоге это может привести к ошибкам в работе функции.


# Области видимости 

Существует две области видимости локальная и глобальная 
все что существует вне функции является глобальным, а внутри функции локальным.

## LEGB
Этой аббревиатурой обозначаются принятые в питоне области видимости, а именно LEGB означает Local, Enclosing, Global и Built-in.
L - локальная область видимости, которая создается при вызове функции. На каждый вызов функции создается своя область видимости.
E - Охватывающая область видимости. Она существует только для вложенных функций. Имена внешних функций видны и в функции, которые вызываются внутри ее
G - Это глобальная область видимости, она является главной в пайтен файлах или скриптах и ее переменные можно использовать во всех функциях.
B - Встроенная область видимости, которая создается когда запускаются скрипты или REPL. 

Питон ищет переменные по этому правилу. 

## global and nonlocal


Глобал обозначает переменную как глобальную. А нонлокал обращается в переменной в ближайшей локальной зоне видимости.

```python
x = 10  # Глобальная переменная

def outer():
    x = 20  # Локальная переменная в outer

    def inner():
        nonlocal x  # Ссылка на x в outer
        x = 30

    inner()
    print(x)  # Выведет 30

outer()
print(x)  # Выведет 10 (глобальная переменная не изменилась)
```

```python
x = 10

def modify_global():
    global x
    x = 20

modify_global()
print(x)  # Выведет 20
```


# Замыкание

```python
def id_generator(user):
    value = 0


    def make_num():
        nonlocal value
        value += 1
        answer = f"{user}-{value:03d}"
        return answer


    return make_num
    
user_id = id_generator("USER")
print(user_id())  # => "USER-001"
print(user_id())  # => "USER-002"
```

**Замыкание** — это сочетание функции и окружения, где она была заявлена. Другими словами, это всего лишь название функции, которая запоминает внешние штуки, используемые внутри.
то есть по сути  user_id тут становится функцией, которая запоминает состояние счетчика.

# Разделение команд и запросов
Command-query Separation (CQS) — принцип программирования, изобретённый Бертандом Майером, создателем языка Eiffel.

Он утверждал, что каждая функция является либо командой, которая выполняет определенное действие(action), либо запросом (query), но не тем и другим одновременно.  При этом команда всегда всегда сопровождается побочным эффектом, а чистыми функциями могут быть только функции с запросами.

## Команда

Команды как правило являются не детерминированными и сопровождаются побочными эффектами. Например команда с открытием файла возвращает файловый дискриптер. 
```python 
file = open('/etc/hosts', 'r')
```

## Запрос

Запрос не должен ничего менять. Если запрос меняет файлы, то это уже неправильно, ведь создаются побочные. Отсутствие изменения в запросах - очень важный принцип, который нужно соблюдать всегда.

# Объекты первого класса 

Объекты первого класса или рода, являются те объекты, которые можно передавать в функции и возвращать их из функций. Это могут быть как данные разных типов, так и функции, и получается мы можем передавать функции в переменные.

# Анонимные функции 

В питоне можно использовать анонимные функции. Называются они так, потому, что у них нет имени. Обозначаются они словом `lambda`. 
```python
lambda x: x + 2
```

У синтаксиса лямбда-функций есть несколько особенностей:

- Параметры анонимных функций не заключены в скобки. Но все средства для описания параметров доступны в полной мере — и именованные параметры, и `*args` с `**kwargs`
- Тело лямбда-функции — это всегда одно выражение, результат вычисления которого и будет возвращаемым значением. В теле лямбда-функции не получится выполнить несколько действий и не получится использовать многострочные конструкции вроде `for` и `while`. Но зато анонимные функции обычно просто читать, чего было бы сложно добиться, разреши авторам "многострочные" лямбды
- Лямбды не используют `return` - объявление функции является выражением.

Функции можно сохранять в переменные, точнее в переменную будет сохраняться ссылка на функцию. 

```python
a = lambda: 'I love Hexlet'

a() # 'I love Hexlet'

b = a

b() # 'I love Hexlet'
```



Более того, любую функцию можно использовать напрямую, без сохранения в переменной: 
```python
(lambda: print('I love Hexlet'))() # => I love Hexlet
```

Раз лямбда-функция — выражение, мы можем определять её в любом месте программы, допускающем использование выражений, например, в теле другой функции:

```python
def sum(a, b):
  # определили "внутреннюю" анонимную функцию и
  # сохранили в константе innerSum
  inner_sum = lambda x, y: x + y

  # вызвали внутреннюю функцию и
  # вернули результат вызова наружу из sum
  return inner_sum(a, b)

sum(1, 4) # 5
```


# Функции высшего порядка

это функции, которые принимают на вход функции либо возвращают функции либо делают и то и другое сразу.

```python
users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
]

def sort_key(elem):
    return elem['age']

sorted(users, key=sort_key)

print(users)
# => [ { 'name': 'Danil', 'age': 1 },
#      { 'name': 'Vovan', 'age': 4 },
#      { 'name': 'Matvey', 'age': 16 },
#      { 'name': 'Igor', 'age': 19 } ]
```

так же туда можно передавать сразу анонимные функции, для упрощения чтения кода

```python
sorted(users, key=lambda user: user['age'])

#   [ { 'name': 'Danil', 'age': 1 },
#     { 'name': 'Vovan', 'age': 4 },
#     { 'name': 'Matvey', 'age': 16 },
#     { 'name': 'Igor', 'age': 19 } ]
```

# Декораторы 

Декораторы в python это функции , которые принимают в качестве аргументов другие функции и добавляют им функционал.  Как пример 
```python
def log_decorator(fn):
    def wrapper(*args, **kwargs):
        print(f"Вызываем функцию {fn.__name__} с аргументами {args}{kwargs}")
        answer = fn(*args, **kwargs)
        print(f"Функция {fn.__name__} вернула результат {answer}")
        return answer
    return wrapper



@log_decorator
def add(a, b):

    return a + b

add(2, 2)
```

Внутреннюю функцию в таком случае принято называть `warpper` 

Декораторы нужна для добавление функционала, логов, таймеров и тд

# Ленивые вычисления 

это стратегия в которой вычисления откладываются на последний момент, пока не понадобится их результат. 
Пример:
```python
True or print("Massage")
```
## Работа с коллекциями
Ленивые вычисления особенно полезны для работы с коллекциями. 

```python
numbers = [1, 2, 3, 4, 5]

# получим итератор явно
it = iter(numbers)

for elem in it:
    print(elem)
    # прервем выполнение
    if elem == 3:
        break

# => 1
# => 2
# => 3

# и вернемся позже
for elem in it:
    print(elem)

# => 4
# => 5
```

Итераторы представляют поток данных, который позволяет обращаться с элементам по запросу.  Они используются для экономии вычислительных ресурсов.

## Генераторы 

Это функции, которые могут вести себя как итераторы и генерировать значения на каждом шаге итерации 

```python
def gen_squares_to(n):
    i = 1
    while i <= n:
        yield i ** 2
        i += 1

for n in gen_squares_to(5):
    print(n)

# => 1
# => 4
# => 9
# => 16
# => 25
```

Определяются с использованием ключевого слова `yield` вместо `return`.
Генераторы могут создать бесконечные потоки данных 

# Отображение (map)

```python
numbers = [5, 2, 3]

new_numbers = map(lambda number: number ** 2, numbers)
list(new_numbers) # => [25, 4, 9]

new_numbers_2 = map(lambda number: number + 3, numbers)
list(new_numbers_2) # => [8, 5, 6]
```

Это функция высшего порядка. Она принимает в себя два аргумента. Первый - функция, второй - коллекция. И возвращает итератор. Эта функция использует ленивые вычисления. Потом с помощью `list` ее можно преобразовать в список.

```python
users = [
  { 'name': 'Igor', 'age': 19 },
  { 'name': 'Danil', 'age': 1 },
  { 'name': 'Vovan', 'age': 4 },
  { 'name': 'Matvey', 'age': 16 },
]

names = map(lambda user: user['name'], users)
print(list(names))
```

# Фильтрация `filter()`

Работает как и map только функция должна быть предикатом. Возвращает отфильтрованную коллекцию. Так же работает через итератор. 
```python
filtered_users = filter(lambda user: user['age'] > 10, users)
print(filtered_users) # <filter at 0x71de32b28040>

list(filtered_users) # => [{'name': 'Igor', 'age': 19}, {'name': 'Matvey', 'age': 16}]
```

# Агрегация (reduce)

Это операция, когда мы из многих значений получаем одно итоговое.
Саму функцию нужно импортировать:
```python
from functools import reduce
```
Вот пример кода с ней 
```python
functools import reduce

users = [
  { 'name': 'Igor', 'amount': 19 },
  { 'name': 'Danil', 'amount': 1 },
  { 'name': 'Ivan', 'amount': 4 },
  { 'name': 'Matvey', 'amount': 16 },
]

total = reduce(lambda acc, user: acc + user['amount'], users, 0)
print(total)  # => 40thon
```

Эта функция высшего порядка, она принимает на вход три аргумента. Функцию, через которую будут прогоняться элементы, коллекцию, и аккумулятор. Аккумулятор - самое важное, это изначальное значение от которого будет отталкиваться функция.


# Comprehensions

## Генераторы списков 

Это компактный способ для создания списков,  он позволяет записывать циклы и условия в одной строке.

```python
users = [
  { 'name': 'Igor', 'age': 19 },
  { 'name': 'Danil', 'age': 1 },
  { 'name': 'Vovan', 'age': 4 },
  { 'name': 'Matvey', 'age': 16 },
]

names = [user['name'] for user in users if user['age'] > 10]
# ['Igor', 'Matvey']
```

Основной скелет такого выражения это 

```python
[ВЫРАЖЕНИЕ for ПЕРЕМЕННАЯ in ИСТОЧНИК if УСЛОВИЕ]
```
- **ВЫРАЖЕНИЕ**: вычисляется для каждого элемента и добавляется в новый список.
- **ПЕРЕМЕННАЯ**: имя, которое принимает значения из ИСТОЧНИКА.
- **ИСТОЧНИК**: любой итерируемый объект.
- **УСЛОВИЕ**: фильтрует элементы, которые будут добавлены в новый список.


## Генерация словарей 

Так же в пайтен можно генерировать с словари. Главное отличии в том, что нужно так же генерировать ключи. 

```python
char_positions = {char: pos for pos, char in enumerate("Hello, World!")}
char_positions
# {'H': 0, 'e': 1, 'l': 10, 'o': 8, ',': 5, ' ': 6, 'W': 7, 'r': 9, 'd': 11, '!': 12}
char_positions['o']
# 8
```
Важно помнить, что если ключи одинаковые, будет храниться последнее значение, которое передавалось.


## Генераторные выражения: краткий конспект

1. **Что это?**
   Генераторные выражения — это ленивый способ обработки данных, который позволяет вычислять элементы **по одному**, а не сразу создавать всю коллекцию (как в списочных или словарных выражениях).

2. **Синтаксис**:
   Генераторные выражения выглядят как списочные выражения, но с **круглыми скобками**:
   ```python
   (x * x for x in range(10))
   ```

3. **Преимущества**:
   - **Экономия памяти**: данные вычисляются постепенно, что особенно полезно для работы с большими объёмами данных.
   - **Быстродействие**: элементы обрабатываются только тогда, когда они действительно нужны.

4. **Пример использования**:
   ```python
   any(x > 100 for x in range(1000000))
   ```
   Генератор проверяет числа по одному, а не создаёт список из миллиона элементов.

5. **Где применять**:
   - Для работы с большими данными.
   - Вместе с функциями: `sum`, `any`, `all`, `map()`, `filter()`.
   - Внутри других выражений, таких как `list`, `set`, `dict`, и для передачи аргументов в функции.

6. **Упрощение кода**:
   Генераторные выражения делают код более **лаконичным**. Например:
   ```python
   print(*(x for x in "Hello World!" if x.isupper()))
   # Вывод: H W
   ```



## Цепочка операций

Лучше разбивать задачу на функции и не использовать циклы. Нужно соединять функции и создавать из них цепочки. 

типо такого 

```python
import pathlib

# описываем предикат
def is_py_file(path):
  return pathlib.Path(path).is_file() \
        and pathlib.Path(path).suffix.lower() == '.py'

def get_py_file_names(paths):
    # используем генераторное выражение, чтобы не создавать промежуточные списки
    py_files = (path for path in paths if is_py_file(path))

    return [pathlib.Path(path).stem.lower() for path in py_files]

names = get_py_file_names(['solution.py', 'solution_test.py', 'README.md', '.venv'])
print(names) # => ['solution', 'solution_test']
```

# Парадигмы программирования 


Парадигма программирования - это совокупность идей и понятий, которые определяют стиль написания компьютерных программ. Это не только логика написания кода, но в целом то как будет устроена программа под капотом.


## Императивная парадигма

это - стиль написания кода в виде набора последовательных инструкций с активным использованием переменных, так же используется память для промежуточного хранения данных.
Так же в этом стиле активно используется присваивание. Эта парадигма популярна, потому, что она работает так, как работает сам компьютер.
Обычно говорят, что императивная программа отвечает на вопрос КАК («как достичь нужного результата»).

## Декларативная парадигма

Императивному стилю противопоставляют декларативный, который нередко называют функциональным. Ключевое отличие функционального стиля от императивного в том, что при таком стиле программа выглядит как спецификация (которая может быть очень сложной), а не как набор инструкций. То есть программа отвечает на вопрос _ЧТО_ («что мы хотим получить»). Эту грань довольно трудно уловить сразу, но, например, вся математика, по своей сути, декларативна.



# Рекурсия 

Это когда функция вызывает сама себя. Для правильной работы рекурсии в ней должен описываться базовый случай и уже после только вызов функцией себя.

фактически это выглядит так 
```python
def factorial(n):
    if n == 0
        return 1

    return n * factorial(n - 1)
```


```python
factorial(3)
3 * factorial(2)
3 * 2 * factorial(1)
3 * 2 * 1 * factorial(0)
3 * 2 * 1 * 1
3 * 2 * 1
3 * 2
6
```

фактически это будет выглядеть вот так.
Есть много видов рекурсий 




