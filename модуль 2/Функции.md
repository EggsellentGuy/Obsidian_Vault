# Введение 
Функции мощный инструмент в python, их бывает много видов и они могут принимать различное количество аргументов. Так же бывают анонимные функции, которые сильно расширяют функционал языка. 

## Переменное количество аргументов

Переменное количество аргументов может принимать функция с помощью символа `*`, выглядит это примерно `*args`. 
Аргументы автоматически упаковываются в кортеж 
```python
def f(x, *args):
    print(f'Первый аргумент: {x}')
    for a in args:
        print(f'Другой аргумент из *args {a}!')

f('Programming language', 'Python', 'PHP', 'Java')
# => Первый аргумент: Programming language
# => Другой аргумент из *args Python!
# => Другой аргумент из *args PHP!
# => Другой аргумент из *args Java!

f()
# TypeError: f() missing 1 required positional argument: 'x'
```

Здесь функция принимает несколько аргументов, но как минимум один должен быть передан всегда. Первый аргумент станет значением переменной x, а остальные сохранятся в *args. Так можно делать любое нужное количество обязательных аргументов.

## Передача аргументов в форме коллекции

Иногда нужно сначала сформировать набор аргументов, а потом передать их функции. Допустим, прочитать параметры из файла или получить другим программным способом. Здесь снова пригодится оператор `*`:
```python
def sum(a, b):
    return a + b

nums = [3, 4]
sum(*nums) # 7
```
Часть аргументов можно подставлять сразу в функцию и даже подставлять несколько коллекций сразу:
```python
def greet(*names):
    for name in names:
        print(f'Hello, {name}!')

greet(
   'Bob', *['Mary', 'Clair'], 'Sam',
   *('Henry', 'John')
)
# => Hello, Bob!
# => Hello, Mary!
# => Hello, Clair!
# => Hello, Sam!
# => Hello, Henry!
# => Hello, John!
```
В приведенном примере мы передали в функцию greet набор одиночных аргументов и коллекций. При помощи оператора * функция greet вызывается с шестью аргументами: 'Bob', 'Mary', 'Clair', 'Sam', 'Henry' и 'John'. Результатом этого кода будет шесть приветствий по одному для каждого аргумента. Они будут в том порядке, в котором их передали в функцию.

# Именованные параметры

При вызове функции с позиционными параметрами важную роль играет порядок размещения передаваемых аргументов.

```python
def bar(length, char1, char2):
    return (char1 + char2) * length + char1

print(bar(5, '-', '*'))
# => -*-*-*-*-*-
```

## Именованный аргументы

Чтобы передать именованные аргументы в функцию, нужно указать их имена, которые были заданы при объявлении функции:
```python
def bar(length, char1, char2):
    return (char1 + char2) * length + char1

print(bar(length=3, char1='-', char2='*'))
# => -*-*-*-
print(bar(char1='-', char2='*', length=3))
# => -*-*-*-
print(bar(char2='*', length=3, char1='-'))
# => -*-*-*-
```

При обращении к параметрам функции таким образом ключевую роль играет имя параметра, а не его позиция.

## Значения параметров по умолчанию

Можно задать параметры по умолчанию и в случаи, если значение не передано в функцию, то будет использоваться значение по умолчанию.
```python 
def bar(length, char1='-', char2='*'):
    return (char1 + char2) * length + char1

print(bar(5))
# => -*-*-*-*-*-
print(bar(3, '.'))
# => .*.*.*.
print(bar(2, ':', '|'))
# => :|:|:
```

здесь имеет значение порядок групп аргументов — позиционные значения должны быть указаны до именованных. Иначе мы получим ошибку:

```python
print(bar(char2='%', 2))
# => SyntaxError: positional argument follows keyword argument
```

Если у функции есть позиционные параметры без значений по умолчанию, значения для этих параметров все равно нужно указать либо в виде позиционных значений, либо в виде именованных. Нарушение этого правила приведет к ошибке вида:

```python 
bar(char2='!')
# TypeError: bar() missing 1 required positional argument: 'length'
```

Нужно различать синтаксис объявления параметров функции и синтаксис вызова функции. При вызове функции у нас больше свободы. Например, можно указывать именованные параметры перед разворачиваемой группой позиционных:

```python
def f(*args, x=None, y=None):
    print('args =', args, ', x =', x, ', y =', y)

f(*(1, 2), x='a', *[3, 4], y='b', *(5, 6))
# => args = (1, 2, 3, 4, 5, 6), x = a, y = b
```


# Порядок параметров в функции

1. Обычные позиционные параметры
2. Параметр `*args`
3. Параметры со значением по умолчанию
4. Параметр `**kwargs`


## Передача именованных аргументов с помощью словаря

аргументы в функцию можно передавать через словарь, для этого нужно поставить `**` перед аргументом.

```python
def coords(x, y):
    return (x, y)

coords(x=1, **{'y': 2})
# (1, 2)
```
Или более сложный пример:

```python
def f(x, y, *args, kx=None, ky=42, **kwargs):
    return (x, y, args, kx, ky, kwargs)

positional = (2, 3)
named = dict(ky='b', kz='c')
f(1, *positional, 4, kx='a', **named)
# (1, 2, (3, 4), 'a', 'b', {'kz': 'c'})
```

В этом примере мы создали словарь функцией `dict` с несколькими именованными аргументами. Так словарь еще больше похож на сохраненный набор аргументов.

При подстановке аргументов разворачивающиеся наборы аргументов вроде `*positional` и `**named` можно указывать вперемешку с аргументами соответствующего типа: `*positional` — с позиционными, `**named` — с именованными. При этом все именованные аргументы должны идти после всех позиционных.


## Keyword-only аргументы

```python 
def open_file(name, *, writable=False, binary=False):
    …

f1 = open_file('foo.txt', writable=True)
f2 = open_file('bar.bin', binary=True)
f3 = open_file('raw.dat', True, True)
# TypeError: open_file() takes 1 positional argument but 3 were given
```

Здесь `*` выступает разделителем — отделяет обычные параметры от строго именованных. Такой разделитель можно использовать только один раз в одном определении. Еще его нельзя применять в функциях с `*args`. Но можно объявлять функции, у которых будут только строго именованные аргументы. Для этого нужно поставить звездочку в самом начале перечня аргументов.

Когда мы используем `keyword-only` аргументы вместе с именованными аргументами (`**kwargs`), возникает проблема. Именованные аргументы могут перехватить значения, которые должны были быть переданы как `keyword-only` аргументы. В итоге это может привести к ошибкам в работе функции.


# Области видимости 

Существует две области видимости локальная и глобальная 
все что существует вне функции является глобальным, а внутри функции локальным.

## LEGB
Этой аббревиатурой обозначаются принятые в питоне области видимости, а именно LEGB означает Local, Enclosing, Global и Built-in.
L - локальная область видимости, которая создается при вызове функции. На каждый вызов функции создается своя область видимости.
E - Охватывающая область видимости. Она существует только для вложенных функций. Имена внешних функций видны и в функции, которые вызываются внутри ее
G - Это глобальная область видимости, она является главной в пайтен файлах или скриптах и ее переменные можно использовать во всех функциях.
B - Встроенная область видимости, которая создается когда запускаются скрипты или REPL. 

Питон ищет переменные по этому правилу. 

## global and nonlocal


Глобал обозначает переменную как глобальную. А нонлокал обращается в переменной в ближайшей локальной зоне видимости.

```python
x = 10  # Глобальная переменная

def outer():
    x = 20  # Локальная переменная в outer

    def inner():
        nonlocal x  # Ссылка на x в outer
        x = 30

    inner()
    print(x)  # Выведет 30

outer()
print(x)  # Выведет 10 (глобальная переменная не изменилась)
```

```python
x = 10

def modify_global():
    global x
    x = 20

modify_global()
print(x)  # Выведет 20
```


# Замыкание

```python
def id_generator(user):
    value = 0


    def make_num():
        nonlocal value
        value += 1
        answer = f"{user}-{value:03d}"
        return answer


    return make_num
    
user_id = id_generator("USER")
print(user_id())  # => "USER-001"
print(user_id())  # => "USER-002"
```

**Замыкание** — это сочетание функции и окружения, где она была заявлена. Другими словами, это всего лишь название функции, которая запоминает внешние штуки, используемые внутри.
то есть по сути  user_id тут становится функцией, которая запоминает состояние счетчика.

# Разделение команд и запросов
Command-query Separation (CQS) — принцип программирования, изобретённый Бертандом Майером, создателем языка Eiffel.

Он утверждал, что каждая функция является либо командой, которая выполняет определенное действие(action), либо запросом (query), но не тем и другим одновременно.  При этом команда всегда всегда сопровождается побочным эффектом, а чистыми функциями могут быть только функции с запросами.

## Команда

Команды как правило являются не детерминированными и сопровождаются побочными эффектами. Например команда с открытием файла возвращает файловый дискриптер. 
```python 
file = open('/etc/hosts', 'r')
```

## Запрос

Запрос не должен ничего менять. Если запрос меняет файлы, то это уже неправильно, ведь создаются побочные. Отсутствие изменения в запросах - очень важный принцип, который нужно соблюдать всегда.

# Объекты первого класса 

Объекты первого класса или рода, являются те объекты, которые можно передавать в функции и возвращать их из функций. Это могут быть как данные разных типов, так и функции, и получается мы можем передавать функции в переменные.

# Анонимные функции 

В питоне можно использовать анонимные функции. Называются они так, потому, что у них нет имени. Обозначаются они словом `lambda`. 
```python
lambda x: x + 2
```

У синтаксиса лямбда-функций есть несколько особенностей:

- Параметры анонимных функций не заключены в скобки. Но все средства для описания параметров доступны в полной мере — и именованные параметры, и `*args` с `**kwargs`
- Тело лямбда-функции — это всегда одно выражение, результат вычисления которого и будет возвращаемым значением. В теле лямбда-функции не получится выполнить несколько действий и не получится использовать многострочные конструкции вроде `for` и `while`. Но зато анонимные функции обычно просто читать, чего было бы сложно добиться, разреши авторам "многострочные" лямбды
- Лямбды не используют `return` - объявление функции является выражением.

Функции можно сохранять в переменные, точнее в переменную будет сохраняться ссылка на функцию. 

```python
a = lambda: 'I love Hexlet'

a() # 'I love Hexlet'

b = a

b() # 'I love Hexlet'
```



Более того, любую функцию можно использовать напрямую, без сохранения в переменной: 
```python
(lambda: print('I love Hexlet'))() # => I love Hexlet
```

Раз лямбда-функция — выражение, мы можем определять её в любом месте программы, допускающем использование выражений, например, в теле другой функции:

```python
def sum(a, b):
  # определили "внутреннюю" анонимную функцию и
  # сохранили в константе innerSum
  inner_sum = lambda x, y: x + y

  # вызвали внутреннюю функцию и
  # вернули результат вызова наружу из sum
  return inner_sum(a, b)

sum(1, 4) # 5
```


# Функции высшего порядка

это функции, которые принимают на вход функции либо возвращают функции либо делают и то и другое сразу.

```python
users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
]

def sort_key(elem):
    return elem['age']

sorted(users, key=sort_key)

print(users)
# => [ { 'name': 'Danil', 'age': 1 },
#      { 'name': 'Vovan', 'age': 4 },
#      { 'name': 'Matvey', 'age': 16 },
#      { 'name': 'Igor', 'age': 19 } ]
```

так же туда можно передавать сразу анонимные функции, для упрощения чтения кода

```python
sorted(users, key=lambda user: user['age'])

#   [ { 'name': 'Danil', 'age': 1 },
#     { 'name': 'Vovan', 'age': 4 },
#     { 'name': 'Matvey', 'age': 16 },
#     { 'name': 'Igor', 'age': 19 } ]
```

# Декораторы 

Декораторы в python это функции , которые принимают в качестве аргументов другие функции и добавляют им функционал.  Как пример 
```python
def log_decorator(fn):
    def wrapper(*args, **kwargs):
        print(f"Вызываем функцию {fn.__name__} с аргументами {args}{kwargs}")
        answer = fn(*args, **kwargs)
        print(f"Функция {fn.__name__} вернула результат {answer}")
        return answer
    return wrapper



@log_decorator
def add(a, b):

    return a + b

add(2, 2)
```

Внутреннюю функцию в таком случае принято называть `warpper` 

Декораторы нужна для добавление функционала, логов, таймеров и тд

