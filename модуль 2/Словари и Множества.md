#  Введение
Словари это тип данных, которые выглядят как ключ зачение. В отличии от списков данные в словарях как правило не монотонны, а все же отличаются. 

# Особенности словарей
Если элементы списка или кортежа индексированы, то значения в словаре хранятся по системе ключей, где каждое хранящиеся значение имеет параметр ключа, по которомы к этому значению можно обращаться. *Ключи у словарей должны быть уникальны!* 
Так же словари инотгда называют терменом Ассоциативные массивы, это синонимы 
# Для чего применяются словари
для удобного хранения набора данных, к которому будет удобно обращаться по клбчивым значениям например ник, мало и возраст 
```python

bob = {
	   'name': 'bob',
	   'male': 'bob_super@gmail.com',
	   'age': '30'
}
```

# Синтаксис
Словари записываются в фигурные скобки {}. вот пример 
```python
dictionary = {
    "foo": "bar",
    "baz": 42,
    "items": {
        1: "apple",
        2: "orange",
        100500: "lemon"
    },
    True: "python"
}
dictionary  # {'foo': 'bar', 'baz': 42, 'items': {1: 'apple', 2: 'orange', 100500: 'lemon'}, True: 'python'}
```
Как видно из примера ключами могут быть разные типы данных. Так и значениями могу выступать например другие словари, списки и тд. 

# Доступ к элементам по ключу
Используя квадратные скобки можно получить доступ к элементу. 
```python
dictionary["baz"] # 42
dictionary["BANG"] # KeyError 'BANG' 
```
Если ключа не будет, то мы получим ошибку кейэррор, это как индек эррор, только с ключом
Проверить существует ли такой ключ можно с помощью in
```python
'baz' in dictionary #True
```
Очень крутая и правильная конструкция 
```python
dictionary['BANG'] if BANG in dictionary else None
```
Но эту логику может замениить метод .`get()`
```python
dictionary.get('baz') # 42
dictionary.get('BANG') # None
dictionary.get('BANG', 'no such key') # no such key
```

# Итераторы `keys`, `values` и `items`
`keys` позволяет получить значение ключа 
```python
list({"a": 1, "b": 2}.keys())  # ['a', 'b']
```
`values` позволяет получить само значение 
```python
list({"a": 1, "b": 2}.values())  # [1, 2]
```
`items` позволяет получать пары ключ значение 
```python
for k, v in {"a": 1, "b": 2}.items():
    print(k, "=", v)

# => a = 1
# => b = 2
```

# Изменение данных в словаре 
В python словарь является изменяемым и мутабельным типом даннах. Изменять словари можно обычным присваиванием 
```python
d = {}  # пустой словарь
d["a"] = 100
print(d)  # => {'a': 100}
d["b"] = 200
d["a"] = 0
print(d)  # => {'a': 0, 'b': 200}
```

# Метод `pop`
Этот медот работает так же как и со списком(удаляет элемент и сразу его возвращает), только вместо индексов получает ключи 
```python
d = {'a': 1, 'b': 2}
d.pop('a')  # 1
d  # {'b': 2}
d.pop('BANG')  # KeyError: 'BANG'
```
Так же у этого метода можно указать арогумент, который он будет возвращать в случаи отсутствия такого значения.
```python
d = {'a': 1, 'b': 2}
d.pop('BANG', None) # None
d.pop('BANG', 42)  # 42
```
и так же сущевствует очень полезный метод  `popitem` Этот метод извлекает ключ и значение в виде кортежа, а если словарь уже пуст, то возбуждает исключение:
```python
d = {'a': 1}
d.popitem()  # ('a', 1)
d.popitem()  # KeyError: 'popitem(): dictionary is empty'
```

# Дополнение одного словаря другим
в пайтоне так же можно дополнять словари. для этого используется метод `update`.  Работает это так:
- Новые ключи дописываются в словарь
- Если какие-то ключи уже существовали до этого, то связанные с ними значения будут заменены новыми
```python
cart = {'apples': 2, 'oranges': 1}
addon = {'oranges': 5, 'lemons': 3}
cart.update(addon)
cart  # {'apples': 2, 'oranges': 5, 'lemons': 3}
```

# Копирование словаря
В случае списков мы можем сложить два списка двумя способами:
- Просто сложить два списка и получить новый
- Сделать копию одного списка и дополнить ее данными из второго
Но словари нельзя складывать, да и срезы словари тоже не поддерживают. Зато у словаря есть метод `copy`. Он работает как копирование списка с помощью среза `[:]` — при вызове он возвращает **поверхностную копию** из словаря. Так же ее называют «неглубокой копией» или shallow copy.
Поверхностная копия воспроизводит только структуру словаря: не копирует значения, а только создает на них новые ссылки. Тем не менее поверхностная копия — это новый словарь, который может изменять свой состав, не влияя на оригинал:
```python
d = {'a': 1, 'b': [42]}
c = d.copy()
c.update({'a': 10, '1k': 1024})
c  # {'a': 10, 'b': [42], '1k': 1024}
c['b'].append(None)
c  # {'a': 10, 'b': [42, None], '1k': 1024}
d  # {'a': 1, 'b': [42, None]}
```

# Очистка словаря
Списки можно очистить с помощью присваивания срезу `l[:] = []`. В случае словаря вместо присваивания срезу используется метод `clear`.

Метод `clear()` удаляет все элементы из текущего словаря:
```python
d = {'a': 1}
d.clear()
d  # {}
```


# Инициализация новых значений и defaultdicts
# Инициализация новых значений
Есть такой метод `setdefault`. Он позволяет проверять есть ли такой ключ в словаре и если нет, то создает его и добовляет значение по умолчанию. Вот пример в коде:

```python
dictionary.setdefault(key, []).append(value)
```

## Тип defaultdict

В стандартной поставке Python присутствует модуль collections, который предоставляет тип defaultdict. Во всех отношениях defaultdict — это обычный словарь. При этом у него есть одно уникальное свойство: там, где обычный словарь ругается на отсутствие ключа, defaultdict сам возвращает значение по умолчанию. Давайте рассмотрим пример:
```python
from collections import defaultdict
d = defaultdict(int)
d['a'] += 5
d['b'] = d['c'] + 10
d  # defaultdict(<class 'int'>, {'a': 5, 'c': 0, 'b': 10})
```
Вот еще один пример — на этот раз с самодельной функцией-инициализатором:
```python
def new_value():
    return 'foo'
x = defaultdict(new_value)
x[1]  # 'foo'
x['bar']  # 'foo'
x  # defaultdict(<function new_value at 0x7f2232cf5a60>, {1: 'foo', 'bar': 'foo'})
```
# Множества
Это набор данных, которые хранятся в едиственном экземляре.
Множества в Python — это неупорядоченные последовательности элементов, каждый из которых в множестве представлен ровно один раз.
## Создание множеств и манипуляции над ними
```python
s = {1, 2, 3, 2, 1}
s  # {1, 2, 3}
type(s)  # <class 'set'>
```
Но так как `{}` занято словарями то новый множества принято вызывать так:
```python
set()  # {}
type(set())  # <class 'set'>
```
Эту же функцию можно использовать с аргументов для разбивания итерируемых данных на множество. Пример:
```python
set('abracadabra')  # {'c', 'd', 'a', 'r', 'b'}
set([1, 2, 3, 2, 1])  # {1, 2, 3}
set({'a': 42, 'b': 'foo'})  # {'a', 'b'}
```

## Проверка на вхождение
Иногда нужно проверять на вхождение данных в множество для этого можно использовать `in`:
```python
42 in set()  # False
42 in set([42])  # True
'a' in set('abracadabra')  # True
```
Проверка на вхождение в множество выполняется очень быстро — гораздо быстрее, чем проверка на вхождение в строку, кортеж или список. Так же быстро работает поиск ключа в словаре, потому что словари и множества используют один механизм хранения и поиска ключей.

# Изменение множеств
Множества так же можно изменять с помощью мотодов `add` и `discard`. Пример в коде:
```python
s = set()
s.add(1)
s.add(2)
s.add(2)
s  # {1, 2}
s.discard(1)
s  # {2}
s.discard(1)
s  # {2}
s.remove(1)  # KeyError: 1
```
## Копирование и очистка множеств
Множества изменяемы, поэтому требуется сделать копию перед изменением оригинала. Как и словари, множества не поддерживают операцию получения среза. Для копирования приходится использовать метод copy, создающий поверхностную копию множества:
```python
s1 = {1, 2, 3}
s2 = s1.copy()
s1 is s2  # False
s1 == s2  # True
s2.add(4)
s1 == s2  # False
s2  # {1, 2, 3, 4}
```
Очистить множество без пересоздания можно с помощью метода clear:
```python
s = set("foobar")
s  # {'f', 'a', 'r', 'o', 'b'}
s.clear()
s  # set()
```

# Операции над множествами

Множества годятся не только для проверки на вхождения, но и для других операций.

## Проверка на равенство

Множества равны, если ссылаются на одни и те же объекты.

```python
[1, 2, ["foo", "bar"]] == [1, 2, ["foo"] + ["bar"]]  # True
(1, True, []) == (1, True, [])  # True
{"a": 1, "b": 2} == {"b": 2, "a": 1}  # True
```

В Python есть специальный протокол проверки на равенство. Большинство встроенных типов данных поддерживает этот протокол. Мы можем проверять на равенство числа, строки, булевы значения. А еще можем приравнивать кортежи, списки, словари.

## Объединение множеств

При объединении множеств в python возвращается новый объект, который содержит в себе ссылка на объект, который содержится хотя бы в одном из множеств. Это схоже с ИЛИ в булевой логике `|`.

Для объединения множеств в Python используется оператор `|`:

```python
visited_by_masha = {'Paris', 'London'}
visited_by_kolya = {'Moscow', 'Paris'}
visited_by_kolya | visited_by_masha  # {'London', 'Moscow', 'Paris'}
```

## Перечисление множеств

Есть еще операция И. Туда входят объекты, которые есть в первом оригинальном множестве и во втором.

В Python оператор пересечения — `&`:

```python
visited_by_masha = {'Paris', 'London'}
visited_by_kolya = {'Moscow', 'Paris'}
visited_by_kolya & visited_by_masha  # {'Paris'}
```

## Разность множеств

Разность можно представить как вычитание. Она возвращает элементы которые есть в первом множестве, но которых нет во втором. Обозначается знаком `-`.

```python
visited_by_masha = {'Paris', 'London'}
visited_by_kolya = {'Moscow', 'Paris'}
visited_by_masha - visited_by_kolya  # {'London'}
visited_by_kolya - visited_by_masha  # {'Moscow'}
```

## Симметрическая разность

Симметрическая разность двух множеств — это множество, которое содержит все элементы, присутствующие либо в первом множестве, либо во втором, но не в обоих одновременно.

```python
visited_by_masha = {'Paris', 'London'}
visited_by_kolya = {'Moscow', 'Paris'}
visited_by_kolya ^ visited_by_masha  # {'London', 'Moscow'}
```

## Подмножество и надмножество

Одно множество является подмножеством другого (subset), если все элементы первого входят во второе, но второе может содержать еще и другие элементы. Второе в этом случае является надмножеством для первого (superset).  
В Python соотношение множеств можно проверить с помощью методов `issubset` и `issuperset`:

```python
a = {1, 2, 3, 4}
b = {3, 4}
b.issubset(a)  # True
a.issuperset(b)  # True
```

# Методы объектов множеств 
Существуют различные операторы, которые позволяют комбинировать множества.
Они схожи с теми, которые применяются в математике.

## Операции над множествами как методы

У каждого оператора есть свой словесный метод-аналог.
Познакомимся с этими методами-аналогами:
```python
a.union(b)                 # аналог "a | b"
a.intersection(b)          # аналог "a & b"
a.difference(b)            # аналог "a - b"
a.symmetric_difference(b)  # аналог "a ^ b"
```

## Обновление множеств по месту 

Как словари можно обновлять с помощью метода `update`, похожие методы есть и у множеств, вот они:
- ``difference_update``
- ``intersection_update``
- `symmetric_difference_update`
- `update`
Рассмотрим их по подробнее: 

1) Метод `difference_update` работает похоже на `-`/`difference`. Он удаляет из связанного множества все элементы, которые входят в множество-аргумент:

```python
a, b = {1, 2}, {2, 3}
a.difference_update(b)
a  # {1}
```

2) Метод `intersection_update` и его изменяющий аналог `&`/`intersection`. Он оставляет в связанном множестве только те элементы, которые входят и в множество-аргумент:

```python
a, b = {1, 2}, {2, 3}
a.intersection_update(b)
a  # {2}
```

3) Метод `symmetric_difference_update` и его изменяющий аналог `^`/`symmetric_difference`. Он добавляет в связанное множество элементы, которые есть только в множестве-аргументе. Также он удаляет элементы, которые есть в обоих множествах:

```python
a, b = {1, 2}, {2, 3}
a.symmetric_difference_update(b)
a  # {1, 3}
```

4) Метод `update` и его изменяющий аналог `|`/`union`. Он дополняет связанное множество отсутствующими элементами из множества-аргумента:

```python
a, b = {1, 2}, {2, 3}
a.update(b)
a  # {1, 2, 3}
```


# Хэш Таблицы 
Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары «ключ-значение». В разных языках ему соответствуют разные типы данных. В Python — это Dictionary.
Для реализации ассоциативных массивов часто используют специальную структуру данных — хеш-таблицу.
Хеш-таблица позволяет организовать данные ассоциативного массива удобным для хранения способом. Для этого хеш-таблица использует индексированный массив и функцию для хеширования ключей. При этом хеш-таблица — это не просто способ размещать данные в памяти, она включает в себя логику.


## Что такое хеширование
Хеширование — операция, которая преобразует любые входные данные в строку или число фиксированной длины. Функция, реализующая алгоритм преобразования, называется «хеш-функцией». При этом результат хеширования называют «хешем» или «хеш-суммой».

