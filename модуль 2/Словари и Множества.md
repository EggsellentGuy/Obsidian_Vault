#  Введение
Словари это тип данных, которые выглядят как ключ зачение. В отличии от списков данные в словарях как правило не монотонны, а все же отличаются. 

# Особенности словарей
Если элементы списка или кортежа индексированы, то значения в словаре хранятся по системе ключей, где каждое хранящиеся значение имеет параметр ключа, по которомы к этому значению можно обращаться. *Ключи у словарей должны быть уникальны!* 
Так же словари инотгда называют терменом Ассоциативные массивы, это синонимы 
# Для чего применяются словари
для удобного хранения набора данных, к которому будет удобно обращаться по клбчивым значениям например ник, мало и возраст 
```python

bob = {
	   'name': 'bob',
	   'male': 'bob_super@gmail.com',
	   'age': '30'
}
```

# Синтаксис
Словари записываются в фигурные скобки {}. вот пример 
```python
dictionary = {
    "foo": "bar",
    "baz": 42,
    "items": {
        1: "apple",
        2: "orange",
        100500: "lemon"
    },
    True: "python"
}
dictionary  # {'foo': 'bar', 'baz': 42, 'items': {1: 'apple', 2: 'orange', 100500: 'lemon'}, True: 'python'}
```
Как видно из примера ключами могут быть разные типы данных. Так и значениями могу выступать например другие словари, списки и тд. 

# Доступ к элементам по ключу
Искользуя кладратные скобки можно получить доступ к элементу. 
```python
dictionary["baz"] # 42
dictionary["BANG"] # KeyError 'BANG' 
```
Если ключа не будет, то мы получим ошибку кейэррор, это как индек эррор, только с ключом
Проверить существует ли такой ключ можно с помощью in
```python
'baz' in dictionary #True
```
Очень крутая и правильная конструкция 
```python
dictionary['BANG'] if BANG in dictionary else None
```
Но эту логику может замениить метод .get()
```python
dictionary.get('baz') # 42
dictionary.get('BANG') # None
dictionary.get('BANG', 'no such key') # no such key
```

# Итераторы `keys`, `values` и `items`
`keys` позволяет получить значение ключа 
```python
list({"a": 1, "b": 2}.keys())  # ['a', 'b']
```
`values` позволяет получить само значение 
```python
list({"a": 1, "b": 2}.values())  # [1, 2]
```
`items` позволяет получать пары ключ значение 
```python
for k, v in {"a": 1, "b": 2}.items():
    print(k, "=", v)

# => a = 1
# => b = 2
```

# Изменение данных в словаре 
В python словарь является изменяемым и мутабельным типом даннах. Изменять словари можно обычным присваиванием 
```python
d = {}  # пустой словарь
d["a"] = 100
print(d)  # => {'a': 100}
d["b"] = 200
d["a"] = 0
print(d)  # => {'a': 0, 'b': 200}
```

# Метод `pop`
Этот медот работает так же как и со списком(удаляет элемент и сразу его возвращает), только вместо индексов получает ключи 
```python
d = {'a': 1, 'b': 2}
d.pop('a')  # 1
d  # {'b': 2}
d.pop('BANG')  # KeyError: 'BANG'
```
Так же у этого метода можно указать арогумент, который он будет возвращать в случаи отсутствия такого значения.
```python
d = {'a': 1, 'b': 2}
d.pop('BANG', None) # None
d.pop('BANG', 42)  # 42
```
и так же сущевствует очень полезный метод  `popitem` Этот метод извлекает ключ и значение в виде кортежа, а если словарь уже пуст, то возбуждает исключение:
```python
d = {'a': 1}
d.popitem()  # ('a', 1)
d.popitem()  # KeyError: 'popitem(): dictionary is empty'
```

# Дополнение одного словаря другим
в пайтоне так же можно дополнять словари. для этого используется метод `update`.  Работает это так:
- Новые ключи дописываются в словарь
- Если какие-то ключи уже существовали до этого, то связанные с ними значения будут заменены новыми
```python
cart = {'apples': 2, 'oranges': 1}
addon = {'oranges': 5, 'lemons': 3}
cart.update(addon)
cart  # {'apples': 2, 'oranges': 5, 'lemons': 3}
```

# Копирование словаря
В случае списков мы можем сложить два списка двумя способами:
- Просто сложить два списка и получить новый
- Сделать копию одного списка и дополнить ее данными из второго
Но словари нельзя складывать, да и срезы словари тоже не поддерживают. Зато у словаря есть метод `copy`. Он работает как копирование списка с помощью среза `[:]` — при вызове он возвращает **поверхностную копию** из словаря. Так же ее называют «неглубокой копией» или shallow copy.
Поверхностная копия воспроизводит только структуру словаря: не копирует значения, а только создает на них новые ссылки. Тем не менее поверхностная копия — это новый словарь, который может изменять свой состав, не влияя на оригинал:
```python
d = {'a': 1, 'b': [42]}
c = d.copy()
c.update({'a': 10, '1k': 1024})
c  # {'a': 10, 'b': [42], '1k': 1024}
c['b'].append(None)
c  # {'a': 10, 'b': [42, None], '1k': 1024}
d  # {'a': 1, 'b': [42, None]}
```

# Очистка словаря
Списки можно очистить с помощью присваивания срезу `l[:] = []`. В случае словаря вместо присваивания срезу используется метод `clear`.

Метод `clear()` удаляет все элементы из текущего словаря:
```python
d = {'a': 1}
d.clear()
d  # {}
```
