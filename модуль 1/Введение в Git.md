### Введение в Git

### Проблемы, которые решает Git

1. **Сохранение файлов с исходным кодом**
2. **Отслеживание изменений**
3. **Защита от случайных исправлений и удалений**
4. **Отмена некорректных изменений**
5. **Совместная работа над кодом**

### Примеры ситуаций

- **Отмена изменений**: Нужно вернуться к состоянию кода до изменений.
- **Срочное исправление**: Внесение исправлений в версию кода до начала работы над текущей задачей.
- **Совместная разработка**: Два программиста работают над одними и теми же файлами.

### Что такое Git

- **Универсальный инструмент** для контроля версий.
- **Базовые возможности**:
    - Возврат к любой прошлой версии кода.
    - Просмотр истории изменений.
    - Восстановление любых данных.
    - Совместная работа без риска потерять данные или перезаписать чужую работу.

### Интеграция Git

- **Интегрирован во все редакторы кода**.
- **Онлайн-сервисы**: GitHub, GitLab.
- **Хранение кода**: Обеспечивает командный доступ и резервное копирование.

### Сложность и освоение Git

- **Сложная система** с большим количеством команд.
- **Основное ядро**: Достаточно для большинства случаев.
- **Практика и ошибки**: Единственный способ освоить Git.

### Цели курса

- **Установка и настройка Git**.
- **Основные команды**: Добавление, изменение, удаление файлов, анализ истории проекта.
- **Онлайн-сервисы**: GitHub, GitLab.
- **Движение открытого кода**.

### Рекомендации

- **Активное участие в открытых проектах** для лучшего освоения Git.
- **Установка и настройка Git** перед началом курса.

### Заключение

- **Git** — незаменимый инструмент для разработчиков.
- **Практика** — ключ к успешному освоению Git.
- **Открытые проекты** — лучший способ научиться виртуозно владеть Git.

# Введение в Git1

В этом уроке мы поверхностно рассмотрим весь путь от создания проекта в Git до начала отслеживания изменений. В следующих уроках мы подробнее разберем каждый этап. В процессе мы изучим множество новых терминов и команд, необходимых для понимания работы Git.

## Основные команды

Git может отслеживать файлы проекта только после их помещения под контроль версий. Для этого нужно зайти в директорию проекта и выполнить команду инициализации `git init`.

Проект может быть как новым, так и уже существующим. Процесс инициализации от этого не изменится:

```
# Создаем новый проект
mkdir hexlet-git
cd hexlet-git
git init

```

Команда `git init` создает репозиторий — директорию `.git`, которая содержит все необходимые для работы Git-файлы.

С помощью команды `git status` можно посмотреть статус репозитория:

```
git status

```

Вывод будет следующим:

```
On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)

```

Это означает, что репозиторий пустой (No commits yet) — в нем нет новых или измененных файлов.

Давайте попробуем добавить несколько файлов:

```
echo 'Hello, Hexlet!' > README.md
echo 'Haskell Curry' > PEOPLE.md

```

Теперь снова смотрим на статус:

```
git status

```

Вывод будет следующим:

```
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
    README.md

```

Git увидел, что в проекте появились новые файлы, о которых ему ничего не известно. Они помечаются как неотслеживаемые файлы (untracked files).

Добавление в репозиторий происходит в два шага. Первым шагом выполняем команду подготовки файлов `git add <путь до файла>`:

```
git add README.md

```

Смотрим, что произошло:

```
git status

```

Вывод будет следующим:

```
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
    new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.mdA

```

Файл `README.md` теперь находится в состоянии «подготовлен к коммиту» — другими словами, файл попал в индекс.

Следующий шаг — это коммит. Под этим термином понимается окончательное добавление в репозиторий, когда Git запоминает файл навсегда и следит за всеми последующими изменениями.

Во время коммита мы берем все подготовленные изменения и отправляем их в репозиторий как единое целое. Вот, как он выполняется:

```
git commit -m 'add README.md'

```

Вывод будет следующим:

```
[main (root-commit) 3c5d976] add README.md
1 file changed, 1 insertion(+)
create mode 100644 README.md

```

Флаг `-m` означает message, то есть описание коммита. Коммит можно выполнять и без него, но тогда откроется редактор, в котором нужно будет ввести описание коммита.

## Git workflow

Может возникнуть вопрос: зачем так сложно? Зачем отдельно отправлять файлы в индекс командой `git add`? Почему нельзя добавлять все измененные файлы сразу в коммит?

Такой процесс создан для удобства программистов. Во время разработки может меняться и добавляться много файлов, но это не значит, что мы хотим добавить все эти изменения в один коммит.

Коммит — это логически завершенное изменение внутри проекта. Его размер бывает очень разным:

- Маленьким, если мы исправляем одну опечатку в одном файле
- Большим, если мы внедряем новую функциональность

Главное в коммите — его атомарность. Другими словами, он должен выполнять ровно одну задачу.

Теперь файл `README.md` находится внутри репозитория. Убедиться в этом можно, запустив команду `git status`:

```
git status

```

Вывод будет следующим:

```
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md

```

Команда `git status` не выводит файлы, которые добавлены в репозиторий и не содержат изменений. При этом сам файл `README.md` находится внутри директории `hexlet-git`.

---

# Интеграция с GitHub

## Как добавить репозиторий

Сейчас у нас есть репозиторий с двумя коммитами. Содержимое директории `hexlet-git` выглядит так:

```
ls -a

```

```
.git
PEOPLE.md
README.md

```

Перед тем, как продолжить экспериментировать, добавим наш репозиторий на GitHub.

### Шаги для добавления репозитория на GitHub:

1. Зарегистрируйтесь на GitHub и создайте SSH-ключи по инструкции.
2. Создайте репозиторий на GitHub. Назовите его `hexlet-git`. Важно, чтобы репозиторий создавался пустым.
3. На странице репозитория вы увидите готовые команды для подключения созданного репозитория на GitHub к уже существующему репозиторию у вас на компьютере:

```
git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
git branch -M main
git push -u origin main

```

После выполнения этих команд репозиторий на GitHub станет идентичным локальному.

## Как клонировать репозиторий

Репозитории на GitHub делятся на публичные и приватные. Публичный репозиторий любой человек может клонировать себе на компьютер.

### Шаги для клонирования репозитория:

1. Удалите директорию проекта `hexlet-git` с вашего компьютера.
2. Клонируйте репозиторий с помощью команды `git clone`:

```
git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
cd hexlet-git
ls -la

```

Если это ваша первая операция, вы можете увидеть сообщение о подтверждении подлинности хоста. Наберите `yes` и нажмите Enter.

## Как получить изменения с GitHub

Разработчики не только отправляют свои изменения на GitHub, но и забирают их оттуда. Для этого используется команда `git pull --rebase`, которая скачивает новые коммиты из удаленного репозитория и добавляет их в локальный.

### Шаги для получения изменений:

1. Перед началом работы выполните команду:

```
git pull --rebase

```

Это позволит избежать создания ненужных коммитов и упростит отслеживание истории изменений.

## Выводы

В этом уроке мы создали репозиторий с несколькими коммитами и добавили его на GitHub. Теперь его можно склонировать для дальнейшей разработки.

### Польза от использования Git:

- Запасная копия кода на GitHub.
- Возможность восстановления кода в случае потери.
- Возможность делиться кодом с другими.

GitHub — это самая популярная, но не единственная площадка для хостинга репозиториев. Также известны Bitbucket и GitLab, который можно установить на свой сервер для хостинга репозиториев внутри компании.

---

# Рабочая директория

После клонирования репозитория `hexlet-git` мы можем увидеть внутри него директорию `.git` и добавленные нами файлы. Посмотрим, что произойдет, если удалить один из файлов:

```
rm PEOPLE.md
git status

```

Вывод будет следующим:

```
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    deleted:    PEOPLE.md

no changes added to commit (use "git add" and/or "git commit -a")

```

Git сообщает, что файл был удален, и предлагает команды для восстановления или коммита изменений. Откуда Git знает, что файл был удален? Ответ на этот вопрос вы узнаете в этом уроке.

## Как узнать статус репозитория

Внутри директории проекта мы видим файлы проекта и директорию `.git`.

Репозиторием является именно директория `.git`. Она хранит всю информацию о том, какие были изменения, а также сами изменения.

Все, что находится снаружи, это так называемая рабочая директория (working directory). Эти файлы извлекаются из `.git` в момент клонирования.

Каждый раз, когда мы производим изменения в рабочей директории, Git сравнивает измененные файлы с файлами внутри `.git`, то есть их состоянием на момент последнего коммита. Если есть изменения относительно последней зафиксированной версии, то Git сообщает нам об этом в выводе команды `git status`.

Это легко проверить, если восстановить удаленный файл:

```
git restore PEOPLE.md
git status

```

Вывод будет следующим:

```
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean

```

Сам файл вернулся таким, каким он был на момент последнего коммита.

Можно удалить все файлы в рабочей директории и потом без проблем их восстановить. Так мы достигаем важной цели — создаем возможность быстро восстановить последнюю версию кода, если внесенные изменения нас больше не устраивают.

Также мы можем закоммитить изменения, если это нужно:

```
rm PEOPLE.md
git add PEOPLE.md
git commit -m 'remove PEOPLE.md'

```

Вывод будет следующим:

```
[main e15afd2] remove PEOPLE.md
1 file changed, 1 deletion(-)
delete mode 100644 PEOPLE.md

```

Теперь этот файл пропал из рабочей директории.

Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем, процедура выполнения коммита не меняется. После изменений всегда делается `git add`, который подготавливает изменение к коммиту (а не добавляет файл). После этого выполняется коммит.

Кстати, у Git есть команда `git rm`, которая объединяет в себе удаление и подготовку к коммиту:

```
git rm PEOPLE.md

```

Это равносильно `rm + git add`.

![изображение.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b5eeaef4-1668-456e-b4f1-a4f2a1917f61/5582e25e-9691-4d2e-bdc7-de593f769536/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

---

### Анализ истории изменений

### Основные команды:

1. **git log**
2. **git show**
3. **git blame**
4. **git grep**

### Введение:

- Программирование включает не только написание новых программ, но и анализ существующего кода.
- Иногда код может вызывать вопросы: почему он написан так, кто его написал и когда.
- История изменений помогает ответить на эти вопросы.
- Хорошо сделанные коммиты имеют понятное описание и делают ровно одну законченную вещь.
- Важно понимать философию Git и следовать лучшим практикам.

### Команда git log:

- Показывает список всех коммитов, отсортированных по дате добавления.
    
- Пример вывода:
    
    ```
    commit 5120bea3e5528c29f8d1da43731cbe895892eb6d
    Author: tirion <tirion@got.com>
    Date:   Thu Sep 17 18:04:19 2020 -0400
    
        add new content
    
    ```
    
- Флаг `p` выводит диф для каждого коммита.
    

### Команда git show:

- Показывает изменения, сделанные в рамках одного коммита, используя его хеш.
    
- Пример:
    
    ```
    git show 5120bea3e5528c29f8d1da43731cbe895892eb6d
    
    ```
    
- Можно использовать первые семь символов хеша:
    
    ```
    git show 5120bea
    
    ```
    

### Команда git blame:

- Показывает, кто последним менял конкретную строчку в файле.
    
- Пример:
    
    ```
    git blame INFO.md
    
    ```
    
- Вывод:
    
    ```
    e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
    5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line
    
    ```
    

### Команда git grep:

- Ищет совпадение с указанной строкой во всех файлах проекта.
    
- Примеры:
    
    ```
    git grep line
    git grep -i hexlet
    git grep Hexlet 5120bea
    git grep Hexlet $(git rev-list --all)
    
    ```
    

### GitHub:

- Позволяет анализировать проект прямо на платформе.
- Можно просматривать историю коммитов, изменения в конкретном коммите и многое другое.

### Заключение:

- Git предоставляет множество команд для анализа истории изменений.
- Важно понимать и использовать эти команды для эффективного анализа кода.

---

### Отмена коммитов

### Введение

- **Git**: Система, где не нужно бояться ошибок. Ошибки — способ научиться.
- **Восстановление коммитов**: Всегда есть способ восстановить или изменить коммиты.
- **Ситуации для отмены коммитов**:
    - Забыли добавить файлы.
    - Нужно откатить изменения.
    - Изменения больше не актуальны.
    - Изменения сделаны по ошибке.

### Основные команды

- **Git revert**: Создает новый коммит, отменяющий изменения предыдущего коммита.
- **Git reset**: Удаляет коммиты или отменяет их без удаления.

### Git revert

- **Команда**: `git revert <идентификатор коммита>`
    
- **Пример**:
    
    ```bash
    git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
    
    ```
    
- **Результат**: Создается новый коммит, отменяющий изменения указанного коммита.
    
- **Преимущество**: Можно отменить любой коммит из истории.
    

### Команда git reset

- **Удаление коммита**:
    
    ```bash
    git reset --hard HEAD~
    
    ```
    
- **Флаги**:
    
    - `-hard`: Полное удаление коммита.
    - `HEAD~`: Один коммит от последнего.
- **Пример**:
    
    ```bash
    git reset --hard HEAD~
    
    ```
    
- **Без флага --hard**:
    
    - По умолчанию используется `-mixed`.
    - Изменения последнего коммита помещаются в рабочую директорию.
- **Пример**:
    
    ```bash
    git reset HEAD~
    
    ```
    

### Заключение

- **Git revert**: Безопасный способ отмены коммитов.
- **Git reset**: Опасная операция, используется для удаления коммитов.
- **Важно**: Не изменять историю коммитов, если они уже отправлены в удаленный репозиторий.

### Примеры команд

- **Git revert**:
    
    ```bash
    git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
    
    ```
    
- **Git reset**:
    
    ```bash
    git reset --hard HEAD~
    
    ```
    
- **Git reset без --hard**:
    
    ```bash
    git reset HEAD~
    
    ```
    

### Заметки

- **Git revert**: Создает новый коммит, отменяющий изменения.
- **Git reset**: Удаляет коммиты или отменяет их без удаления.
- **HEAD**: Последний сделанный коммит.
- **Флаги**: `-hard`, `-mixed`.

### Практические упражнения

1. **Отмена коммита с помощью `git revert`**:
    - Создайте новый коммит.
    - Используйте `git revert` для отмены этого коммита.
    - Проверьте историю коммитов с помощью `git log`.
2. **Удаление коммита с помощью `git reset`**:
    - Создайте новый коммит.
    - Используйте `git reset --hard HEAD~` для удаления этого коммита.
    - Проверьте историю коммитов с помощью `git log`.
3. **Отмена коммита без удаления с помощью `git reset`**:
    - Создайте новый коммит.
    - Используйте `git reset HEAD~` для отмены этого коммита без удаления.
    - Проверьте статус рабочей директории с помощью `git status`.

---

### Изменение последнего коммита

1. **Проблема**: Разработчики часто забывают добавить часть файлов через `git add` перед коммитом.
2. **Решение**: Если изменения еще не были отправлены во внешнюю систему, можно добавить их в текущий коммит с помощью флага `-amend`.

### Пример использования `-amend`:

1. **Изначальный коммит**:
    
    ```bash
    echo 'experiment with amend' >> INFO.md
    echo 'experiment with amend' >> README.md
    git add INFO.md
    git commit -m 'add content to INFO.md and README.md'
    
    ```
    
2. **Проверка статуса**:
    
    ```bash
    git status
    
    ```
    
    Вывод:
    
    ```
    On branch main
    Your branch is ahead of 'origin/main' by 1 commit.
    Changes not staged for commit:
      modified:   README.md
    
    ```
    
3. **Добавление забытого файла**:
    
    ```bash
    git add README.md
    git commit --amend
    
    ```
    
4. **Проверка статуса после `-amend`**:
    
    ```bash
    git status
    
    ```
    
    Вывод:
    
    ```
    On branch main
    Your branch is ahead of 'origin/main' by 1 commit.
    nothing to commit, working tree clean
    
    ```
    

### Примечания:

- `-amend` не добавляет изменения в существующий коммит, а создает новый коммит с новыми данными.
    
- Чтобы избежать открытия редактора для ввода описания коммита, можно добавить опцию `-no-edit`:
    
    ```bash
    git commit --amend --no-edit
    
    ```
    

Этот метод позволяет исправить последний коммит, не создавая новый, если изменения еще не были отправлены во внешнюю систему.