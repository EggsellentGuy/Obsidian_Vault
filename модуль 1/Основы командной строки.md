## _home/tirion/.bashrc_ **Основы командной строки**

Начнем с самого основного. Проверить, в какой директории мы сейчас находимся, можно командой `pwd`:

```bash
pwd

/Users/guest
```

Изучим команду `ls` (сокращение от _list_). Она выводит список файлов и директорий в текущей рабочей директории:

```bash
ls

Desktop  Documents Downloads Library  Movies  Music  Pictures Public
```

Еще одна полезная команда — `cd` (сокращение от _change directory_). С помощью нее мы перемещаемся по файловой структуре. Для этого ей нужно передать **аргумент** — директорию, в которую необходимо переместиться:

```bash
# Входим в директорию
cd Music
# Смотрим ее содержимое
ls

iTunes
# Если имя директории содержит пробел, то его нужно экранировать с помощью `\\`
cd Best\\ music

```

если просто команды идет что то без -, то это аргумент, а если идет - или —, то это опция

опции так же можно комбинировать

---

Файловая структура *nix-систем серьезно отличается от структуры в Windows и заслуживает отдельного внимания. В этом уроке мы подробнее познакомимся с этой темой.

Начнем с базовых понятий:

- Файловая структура представляет собой **дерево**
- В **узлах** этого дерева находятся **директории** — файлы специального типа
- В **листьях** дерева расположены **файлы**

Схематично такое дерево можно показать так:

![изображение.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b5eeaef4-1668-456e-b4f1-a4f2a1917f61/dac08e1d-5317-439a-8b92-e30670331794/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

# **Команда `cat`**

Самый простой способ прочитать файл — команда `cat`:

```bash
man cat

NAME
     cat -- concatenate and print files

SYNOPSIS
     cat [-benstuv] [file ...]

...
```

# Grep

Слово «грепать» входит в топ самых популярных терминов, используемых разработчиками. Оно происходит от одноименной консольной утилиты `grep` (сокращение от _global regular expression print_). Эта утилита выполняет поиск определенного текста по файлу или файлам.

В некоторых ситуациях нам нужно увидеть не только саму строку, но и текст вокруг нее. Количество выводимых соседних строк регулируется тремя опциями:

- Количество отображаемых строк до искомой строки — `B` или `-before-context`
- Количество отображаемых строк после искомой — `A` или `-after-context`
- Количество отображаемых строк до и после искомой строки — `C` или `-context`

`-r` — она указывает, что надо искать внутри директории.

# **Vim**

Если вы не знаете команд, то лучше ничего не трогать, иначе на экране начнется хаос. Обычное редактирование текста выполняется в режиме ввода — **INSERT**. Попасть в него можно с помощью клавиши i. Для выхода в режим команд достаточно нажать Esc или комбинацию Ctrl + [.

Всего у Vim есть четыре основных режима работы:

- Командный режим — это режим по умолчанию. В нем можно перемещаться по файлу, вносить изменения с помощью комбинаций клавиш, удалять и искать текст
- Режим вставки — это режим ввода текста с клавиатуры. Здесь все работает так, как вы привыкли это делать в обычных редакторах
- Визуальный режим — выделение произвольных участков текста
- Режим командной строки — собственная командная строка для редактора текста, из которой можно выполнять множество разнообразных команд

Говорят, что самое сложное в Vim — это выйти, поэтому подготовимся заранее. Обсудим, как выйти из Vim:

- Убедитесь, что вы находитесь в командном режиме. На всякий случай нажмите или комбинацию
    
    Esc
    
    Ctrl + [
    
- Затем наберите `:` (символ "двоеточие") — эта команда переведет вас в режим командной строки
    
- В конце введите `q!` и нажмите
    
    Enter
    

# Потоки

## Введение

В каждом языке программирования есть свой способ вывода результата на экран. Вот несколько примеров:

- **JavaScript:**
    
    ```jsx
    console.log('hello!');
    
    ```
    
- **PHP:**
    
    ```php
    <?php
    echo 'hello!';
    
    ```
    
- **Python:**
    
    ```python
    print('hello!')
    
    ```
    
- **Java:**
    
    ```java
    System.out.print("hello!");
    
    ```
    
- **Ruby:**
    
    ```ruby
    puts 'hello!'
    
    ```
    

Несмотря на разнообразие языков и способов печати, с точки зрения операционной системы все программы работают одинаково. При старте любой программы операционная система связывает с ней три потока:

1. **STDIN (Standard Input)**
2. **STDOUT (Standard Output)**
3. **STDERR (Standard Error)**

Эти потоки выглядят как файлы, и взаимодействие с ними происходит как с файлами.

## Потоки

### STDOUT

Поток STDOUT отвечает за вывод на экран. Во время каждой печати на экран в программе на любом языке происходят следующие два шага:

1. Функция печати записывает данные в поток STDOUT с помощью функции `write`.
2. Операционная система решает, куда вывести результат. По умолчанию вывод происходит на экран терминала.

### Перенаправление потоков

Операционные системы позволяют подменять потоки при старте системы, что открывает интересные возможности.

### Перенаправление STDOUT в файл

Вывод любой команды в bash можно не выводить на экран, а записать в файл:

```bash
ls -la > output

```

Символ `>` означает, что нужно взять вывод из команды слева и отправить его в файл, указанный справа. Этот символ всегда перезаписывает файл.

### Добавление вывода в файл

Если нужно не перезаписывать, а добавлять, то используйте `>>`:

```bash
echo 'hello' >> result

```

### STDERR и STDIN

Кроме стандартного вывода, с каждым процессом ассоциируются два дополнительных потока:

1. **STDERR** — вывод ошибок.
2. **STDIN** — стандартный ввод.

STDIN работает в обратную сторону: через него программа может получать данные на вход.

### Пример использования STDIN

В *nix-системах встроена утилита `wc` (сокращение от word count). Она умеет считать количество слов, строк или символов в файле:

```bash
wc -l < result

```

Стрелка `<` меняет свое направление в другую сторону и содержимое файла отправляется в поток STDIN запускаемой программы `wc`.

### Объединение перенаправления ввода и вывода

```bash
wc -l < result > output
cat output

```

### Перенаправление STDERR в STDOUT

В unix-системах за каждым потоком закреплен определенный номер, который называется файловым дескриптором:

- **STDIN** — 0
- **STDOUT** — 1
- **STDERR** — 2

Перенаправление STDERR в STDOUT:

```bash
ls lala > output 2>&1
cat output

```

### Перенаправление конкретного потока в файл

Чтобы перенаправить конкретный поток, нужно указать его номер перед `>`:

```bash
cd lala 2> output
cat output

```

### Перенаправление обоих потоков в файл

Этот вариант используется чаще всего. Он помогает проводить отладку и подсказывает, почему вообще возникла та или иная ошибка:

```bash
cd lala &> output
cat output

```

## Заключение

Потоки позволяют программам взаимодействовать с операционной системой и упрощают их реализацию. Благодаря потокам, программы могут быть переносимыми между разными конфигурациями и системами. Перенаправление потоков открывает множество возможностей для управления выводом и ошибками.

# Пайплайн

## Введение

Пайплайн (pipeline) — это метод соединения программ, позволяющий передавать данные от одной программы к другой. Это создает цепочку функций, где каждое звено выступает в роли преобразователя или фильтра.

## Основы пайплайна

### Пример использования пайплайна

Когда мы используем команду `grep` для поиска слов, мы можем искать по нескольким словам одновременно. Например:

```bash
grep alias .bashrc | grep color

```

Символ `|` называется пайп. Он указывает, что командная оболочка должна взять поток STDOUT одного процесса и соединить его с потоком STDIN другого процесса.

### Пример с использованием `cat`

Запись `grep alias .bashrc | grep color` можно изменить, используя перенаправление:

```bash
cat .bashrc | grep alias | grep color

```

В этом примере файл `.bashrc` читается командой `cat` и отправляется в поток STDIN команды `grep`.

### Пример с несколькими командами

```bash
cat source | grep Dog | uniq | sort

```

Рассмотрим, как этот пример работает по шагам:

1. Читается файл `source`.
2. Грепаются входные данные по подстроке `Dog`.
3. Убираются дубли (в исходном файле две одинаковых строки `Dog`).
4. Сортируются входные данные и выводятся на экран.

## Философия Unix

Пайплайн стал основой философии Unix, которая включает следующие принципы:

1. **Пишите программы, которые делают что-то одно и делают это хорошо.**
2. **Пишите программы, которые бы работали вместе.**
3. **Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.**

Большинство утилит Unix работают с сырым текстом — принимают его на вход и возвращают в поток STDOUT.

## Преимущества пайплайна

Такой подход позволяет получать сложное поведение из крайне простых составных блоков. Это напоминает конструктор Lego, где из простых элементов можно создать сложные конструкции.

## Заключение

Пайплайн — это мощный инструмент, который позволяет соединять программы и передавать данные между ними. Благодаря этому подходу, можно создавать сложные цепочки команд, используя простые и понятные утилиты.

# Манипулирование файловой структурой

## Введение

Файловую структуру можно не только просматривать, но и модифицировать. В прошлом уроке мы научились создавать файлы через перенаправление потоков, а сейчас обсудим, как это делать напрямую.

Учтите, что возможность модифицировать файловую структуру зависит от прав пользователя. Если у вас нет соответствующих прав, вы получите ошибку доступа. Место, где вы гарантированно можете экспериментировать — ваша домашняя директория. Внутри нее все доступно на запись.

Для примеров этого урока мы создали каталог `test` в домашней директории. То есть все демонстрируемые команды выполняются в директории по адресу: `~/test`.

## Основные команды

### Создание файлов

Для создания файлов используется утилита `touch`. Основная задача этой утилиты — изменить время последнего доступа к файлу, но она также создает файл, если его не существует:

```bash
# В текущей директории создается пустой файл
touch empty-file

```

### Удаление файлов

Удалить файл можно командой `rm` (сокращение от `remove`):

```bash
rm empty-file

```

### Переименование файлов

В *nix-системах не существует понятия «переименовать файл». Переименование всегда равносильно перемещению, которое выполняется командой `mv` (move):

```bash
touch file
mv file renamed-file

```

### Копирование файлов и директорий

Для копирования файлов и директорий используется утилита `cp` (copy). У этой утилиты два аргумента: имя источника (откуда копируем) и имя приемника (куда копируем):

```bash
cp renamed-file renamed-file-copy

```

Для копирования директории нужно добавить флаг `-r` (recursive):

```bash
cp -r source-dir destination-dir

```

### Создание директорий

Создание директории выполняется командой `mkdir` (make directory):

```bash
mkdir my-dir

```

По умолчанию эта команда не создает вложенных директорий. Для создания вложенных директорий используйте флаг `-p` (--parents):

```bash
mkdir -p one/two/three

```

### Удаление директорий

Удаление директорий выполняется той же командой, что и удаление файлов, но без флагов оно выдает предупреждение:

```bash
rm my-dir/
rm: cannot remove 'my-dir/': Is a directory

```

Чтобы избежать ошибки, нужно добавить флаг `-r` (recursion). Этот флаг включает режим рекурсивного удаления содержимого директорий:

```bash
rm -r my-dir

```

### Принудительное удаление

Если внутри директории содержатся файлы или директории с ограниченными правами доступа, команда `rm` начнет задавать вопрос по каждому из них. Чтобы избежать этого, добавьте флаг `-f` (--force). Этот флаг позволяет игнорировать несуществующие файлы и не запрашивать подтверждение на удаление:

```bash
rm -rf one

```

## Заключение

Теперь вы знаете основные команды для манипулирования файловой структурой в командной строке. Эти команды позволяют создавать, удалять, переименовывать и копировать файлы и директории, а также работать с вложенными структурами.

### Переменные окружения

### Команда `cd` и домашняя директория

- Команда `cd` без аргументов переходит в домашнюю директорию пользователя.
- Команда `cd` использует переменную окружения для определения домашней директории.

### Что такое переменные окружения

- Переменные окружения похожи на переменные в языках программирования.
- Они существуют в рамках запущенной сессии командной оболочки и пропадают при закрытии терминала.
- Посмотреть установленные переменные можно командой `env`.

### Примеры переменных окружения

- `TERM=xterm-256color`
- `SHELL=/bin/bash`
- `LC_ALL=en_US.UTF-8`
- `USER=kirill.m`
- `HEXLET_VERSION=v2711`
- `PATH=/home/kirill.m/bin:/home/kirill.m/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin`
- `PWD=/home/kirill.m`
- `LANG=en_US.UTF-8`
- `SHLVL=1`
- `HOME=/home/kirill.m`
- `LOGNAME=kirill.m`

### Основное предназначение переменных окружения

- Конфигурирование системы и программ.
- Универсальность и отвязка от способа появления значений в системе.

### Пример использования переменной `HOME`

- Команда `cd` использует переменную `HOME` для определения домашней директории.
- Без переменной окружения пришлось бы каждый раз указывать домашнюю директорию или читать её из конфигурационного файла.

### Базовый набор переменных

- Некоторые переменные всегда устанавливаются `bash` при старте.
- Пример: `HOME`.

### Изменение переменных окружения

- Локальное изменение: `HOME=/tmp cd` (изменяет переменную только для конкретного запуска команды).
- Глобальное изменение: `export HOME=/tmp` (изменяет переменную для всей сессии).

### Переменная `PATH`

- Важная переменная, которая будет рассмотрена в отдельном уроке.

### Примеры команд

```bash
# Вывод значения переменной HOME
echo $HOME

# Локальное изменение переменной HOME
HOME=/tmp cd
pwd

# Глобальное изменение переменной HOME
export HOME=/tmp
cd
pwd

```

### Заключение

- Переменные окружения играют ключевую роль в конфигурировании системы и программ.
- Существуют локальные и глобальные способы изменения переменных окружения.
- Переменная `PATH` будет рассмотрена в отдельном уроке.

### История

### Основы работы с историей команд

- **Просмотр истории**: Нажимайте клавиши «вверх» и «вниз» для просмотра предыдущих и следующих команд.
- **Файл истории**: История команд `bash` хранится в файле `.bash_history` в домашней директории пользователя.
- **Запись команд**: Команды записываются в `.bash_history` при завершении сеанса.
- **Переменная окружения `HISTFILESIZE`**: Определяет количество команд, хранящихся в истории. Если переменная не установлена, история не обрезается и файл растет бесконечно.

### Пример содержимого `.bash_history`

```bash
tail .bash_history

rm -r one/
env
HOME=/tmp cd
pwd
cd
echo $HOME
export HOME=/tmp
id
exit
id

```

### Команда `history`

- **Просмотр истории**: Выполните команду `history` для отображения содержимого файла `.bash_history` с номерами команд.
- **Ограничение вывода**: Используйте `history 5` для отображения последних пяти команд.
- **Повторный запуск команды**: Используйте `!номер_команды` для повторного выполнения команды из истории.

### Пример использования `history`

```bash
history

 1  docke rps
 2  free -m
 3  docker ps
 4  docker exec -it 8678a6520641 bash
 5  ls
 6  exit
 7  docker ps
 8  docker exec -it 1209b6e5ce6b bash
 ...

# Повторный запуск команды с номером 2
!2

free -m
              total        used        free      shared  buff/cache   available
Mem:           1998        1532          75          21         390         227
Swap:             0           0           0

```

### Поиск в истории

- **Поиск с помощью `grep`**: Используйте `history | grep ключевое_слово` для поиска команд в истории.
- **Реверсивный поиск**: Нажмите `Ctrl + r` для запуска поиска по истории. Введите символы для поиска и нажмите `Ctrl + r` снова для поиска следующего соответствия.

### Пример использования `grep`

```bash
history | grep export

 174  export HOME=/tmp
 183  history | grep export

```

### Реверсивный поиск

- **Запуск поиска**: Нажмите `Ctrl + r` и введите символы для поиска.
- **Повторный поиск**: Нажмите `Ctrl + r` снова для поиска следующего соответствия.

### Продвинутый поиск с `fzf`

- **Утилита `fzf`**: Продвинутая версия поиска по истории, работающая через утилиту `fzf`.

### Заключение

- История команд `bash` хранится в файле `.bash_history`.
- Команда `history` позволяет просматривать и повторно выполнять команды.
- Поиск по истории можно выполнять с помощью `grep` и реверсивного поиска (`Ctrl + r`).
- Продвинутый поиск возможен с использованием утилиты `fzf`.

### Пользователи и группы

### Введение

- Взаимодействие с операционной системой всегда ведется от имени конкретного пользователя.
- Тема пользователей и групп важна для понимания прав пользователей.

### Права пользователей

- Любой процесс в системе запускается от имени пользователя.
- Права пользователя ограничивают возможности процесса по влиянию на файловую систему.
- Процессы могут запускаться автоматически при загрузке системы.

### Команда `whoami`

- Команда `whoami` показывает имя текущего пользователя.

```bash
whoami

```

### Команда `ps aux`

- Команда `ps aux` выводит отчет о работающих процессах и их пользователях.

```bash
ps aux

```

### Пример вывода `ps aux`

```bash
root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash
root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]
kirill.m 11116  0.0  0.0  45276  1408 ?        Ss   08:50   0:00 /lib/systemd/systemd --user
kirill.m 11119  0.0  0.0  61148  1860 ?        S    08:50   0:00 (sd-pam)
kirill.m 11194  0.0  0.0  92796  1800 ?        S    08:50   0:00 sshd: kirill.m@pts/0
kirill.m 11195  0.0  0.2  21388  4448 pts/0    Ss   08:50   0:00 -bash
root     12195  0.0  0.0      0     0 ?        S    10:13   0:00 [kworker/u30:1]
root     12880  0.0  0.1  92796  2748 ?        Ss   08:55   0:00 sshd: alexander.v [priv]
alexand+ 12883  0.0  0.0  45276  1924 ?        Ss   08:55   0:00 /lib/systemd/systemd --user
alexand+ 12884  0.0  0.0  61148  1860 ?        S    08:55   0:00 (sd-pam)
alexand+ 12920  0.0  0.1  92796  2420 ?        S    08:55   0:00 sshd: alexander.v@pts/1,pts/2

```

### Владение файлами

- Владелец файла определяется при его создании.
- Пример вывода команды `ls -la`:

```bash
ls -la

total 44
drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 11:34 .
drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..
-rw------- 1 kirill.m kirill.m 2540 Aug 30 07:26 .bash_history
-rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
drwx------ 2 kirill.m kirill.m 4096 Mar 30 18:10 .cache
-rw------- 1 kirill.m kirill.m   55 Aug 28 18:49 .lesshst
drwxrwxr-x 2 kirill.m kirill.m 4096 Aug 29 08:35 .nano
-rw-r--r-- 1 kirill.m kirill.m  655 May 16  2017 .profile
-rw-rw-r-- 1 kirill.m kirill.m    0 Aug 29 11:27 renamed-file
drwx------ 2 kirill.m kirill.m 4096 Jan 22  2018 .ssh
-rw------- 1 kirill.m kirill.m  513 Aug 29 08:06 .viminfo

```

### Идентификатор пользователя (UID)

- Имя пользователя связано с идентификатором UID.
- Команда `id` показывает UID и GID пользователя.

```bash
id

uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

```

### Файл `/etc/passwd`

- Файл `/etc/passwd` хранит информацию о пользователях.
- Пример содержимого файла `/etc/passwd`:

```bash
cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
kirill.m:x:1002:1002::/home/kirill.m:/bin/bash

```

### Права групп пользователей

- Пользователи могут быть членами групп.
- Группы используются для группового доступа к ресурсам.
- Основная группа пользователя указана в выводе команды `id`.

```bash
id

uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

```

### Пользователь `root`

- Пользователь `root` (суперпользователь) имеет идентификатор 0.
- `root` может выполнять любые действия в системе.
- Не рекомендуется использовать `root` на регулярной основе из-за рисков для безопасности системы.

### Заключение

- Пользователи и группы играют ключевую роль в управлении правами доступа в системе.
- Команды `whoami`, `ps aux`, `id`, и файл `/etc/passwd` помогают управлять и анализировать пользователей и их права.
- Пользователь `root` имеет особые привилегии и должен использоваться с осторожностью.

---

### Права доступа

### Ошибка доступа

Разработчики часто сталкиваются с ошибкой доступа:

```
touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied

```

Это указывает на отсутствие прав на создание файлов в каталоге `/etc`.

### Права доступа

Каждый файл ассоциирован с правами доступа:

- `r` — чтение (read)
- `w` — запись (write)
- `x` — исполнение (execute)

Эти права задаются для трех типов пользователей:

- Владельца (User)
- Пользователей, входящих в ту же группу (Group)
- Остальных (Other)

### Пример

```
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc

```

Разделим запись на группы символов:

- `-`— файл
- `rw-` — права владельца (чтение и запись)
- `r--` — права группы (только чтение)
- `r--` — права остальных (только чтение)

### Удаление файла

Удалить файл можно, если есть права на запись в директорию:

```
ls -la /home/ | grep kirill
drwxr-xr-x  5 kirill.m kirill.m 4096 Aug 29 11:34 kirill.m

```

Права для директории:

- `d` — директория
- `rwx` — права владельца (чтение, запись, исполнение)
- `r-x` — права остальных (чтение и исполнение)

### Права доступа в числовой форме

Права доступа могут быть представлены числами:

- `755` — `rwxr-xr-x`
- `644` — `rw-r--r--`

### Изменение владельца и прав доступа

- `chown` — изменение владельца:
    
    ```
    chown kirill .bashrc
    
    ```
    
- `chmod` — изменение прав доступа:
    
    ```
    chmod +r file.txt
    chmod 754 file.txt
    
    ```
    

### Суперпользователь

Пользователь `root` может все, независимо от прав доступа.

### Заключение

Права доступа определяют, кто и как может взаимодействовать с файлами и директориями. Понимание и управление этими правами важно для безопасности и эффективной работы в командной строке.

---

### Выполнение программ

### Введение

- **Запуск программ**: Процесс запуска программ в командной строке включает поиск и выполнение файлов.
- **Проблемы с запуском**: Регулярно возникают у разработчиков, важно понимать механизм запуска.

### Программы и исполняемые файлы

- **Программа**: Это файл или набор файлов на диске.
- **Исполняемый файл**: Один из файлов программы должен быть исполняемым (иметь право `x`).
- **Права доступа**: Программа выполняется только если она исполняемая.

### Механизм запуска программ в *nix-системах

- **Переменная окружения PATH**: Список директорий, где командная оболочка ищет исполняемые файлы.
    
    ```
    echo $PATH
    
    ```
    
- **Пример PATH**:
    
    ```
    /home/hex/.local/bin:/home/hex/bin/:/home/hex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    
    ```
    
- **Поиск программы**: Оболочка перебирает директории слева направо.
    
- **Ошибка при отсутствии файла**:
    
    ```
    wrongname
    bash: wrongname: command not found
    
    ```
    

### Поиск исполняемого файла

- **Команды для поиска**:
    
    ```
    type cp
    whereis cp
    which cp
    ls -al /bin | grep cp
    
    ```
    
- **Пример вывода**:
    
    ```
    -rwxr-xr-x 1 root root  141528 Jan 18  2018 cp
    
    ```
    

### Бинарники и PATH

- **Бинарники**: Исполняемые файлы в директориях, оканчивающихся на `bin`.
- **Пакетные менеджеры**: Переносят бинарники в директории, входящие в PATH (обычно `/usr/local/bin`).

### Расширение PATH

- **Необходимость**: Иногда требуется расширить PATH, особенно при установке программ через пакетные менеджеры языков программирования.
- **Осторожность**: Убедитесь, что это необходимо.

### Запуск программ в текущей директории

- **Безопасность**: Прямой запуск программ из текущей директории не рекомендуется.
    
- **Запуск через точку**:
    
    ```
    ./executable
    
    ```
    
- **Пример процесса**:
    
    1. Переход в директорию `test`.
    2. Нахождение исполняемого файла `executable`.
    3. Попытка запуска по имени (ошибка).
    4. Запуск через точку (успешно).

### Изменение переменной PATH

- **Конфигурационные файлы Bash**:
    
    - `.bashrc`
    - `.bash_profile`
    - `.profile`
- **Добавление пути**:
    
    ```bash
    export PATH=$PATH:/path/to/directory
    
    ```
    
- **Перезапуск терминала**: После изменения конфигурационного файла.
    

### Заключение

- **Понимание механизма запуска**: Важно для решения проблем с исполнением файлов.
- **Правильная установка программ**: Большинство программ самостоятельно добавляют свои исполняемые файлы в нужные места.