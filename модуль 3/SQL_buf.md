
*Date: 09.03.2025*
## Виды соединений 
В языке SQL есть 5 типов соединений 

1) CROSS JOIN 
2) INNER JOIN 
3) LEFT JOIN or LEFT OUTER JOIN
4) RIGHT JOIN or RIGHT OUTER JOIN
5) FULL JOIN or FULL OUTER JOIN

Тип соединения нужно выбирать исходя из ситуации 

### Соединение без условия

В эту группу попадает тип соединения CROSS JOIN 
Составит все возможные комбинации строк из двух таблиц.

Пример:
```sql
SELECT
    color_name,
    material_name
FROM colors
CROSS JOIN materials;
```

### Соединения с условием

В эту группу попадают остальные типы: `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`. В их случаях в результат попадают не все сочетания, а только те, которые удовлетворяют специальному условию соединения.

| Тип соединения                 | Валидные пары | Строки без пары из TableA | Строки без пары из TableB |
| ------------------------------ | ------------- | ------------------------- | ------------------------- |
| **TableA INNER JOIN TableB**   | добавляются   | не добавляются            | не добавляются            |
| **TableA LEFT JOIN    TableB** | добавляются   | добавляются               | не добавляются            |
| **TableA RIGHT JOIN TableB**   | добавляются   | не добавляются            | добавляются               |
| **TableA FULL JOIN TableB**    | добавляются   | добавляются               | добавляются               |
*Table 1. Виды соединений*

#### INNER JOIN

Это соединение отбирает только такие пары строк, которые удовлетворяют специальному условию соединения.

```sql
SELECT
    author_name,
    title
FROM books
INNER JOIN authors ON book_author_id = author_id;
```

#### LEFT JOIN

`LEFT JOIN` используют, когда нужно построить соединение, в котором обязательно будут все строки из первой таблицы. Если для строки из первой таблицы нет подходящих пар во второй таблице, то вместо данных из второй таблицы будут подставлены `NULL`-значения.

```sql
SELECT
    dep.name AS department,
    emp.name AS employee
FROM departments AS dep
LEFT JOIN employees AS emp ON
    dep.department_id = emp.department_id;
```


#### RIGHT JOIN


`RIGHT JOIN` работает похожим образом, но только в результат попадают все строки из второй таблицы, а не из первой.

```sql
SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
RIGHT JOIN employees AS emp ON
    dep.department_id = emp.department_id;
```

#### FULL JOIN

Полное внешнее соединение используют, когда в результате должны быть все строки из обеих таблиц, даже если у них нет подходящей пары. Результат `FULL JOIN` включает в себя результаты `INNER JOIN`, `LEFT JOIN` и `RIGHT JOIN`.

```sql
SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
FULL JOIN employees AS emp ON
    dep.department_id = emp.department_id;
```


## CROSS JOIN подробнее 


`CROSS JOIN` соединяет каждую строку из первой таблицы с каждой строкой из второй таблицы. Поэтому число строк в результате — это произведение количества строк из первой таблицы с количеством строк из второй таблицы. В нашем случае получилось шесть строк — это все возможные сочетания для двух цветов и трех материалов: 2 * 3 = 6.

Следует осторожно пользоваться операцией `CROSS JOIN`, так как результат может оказаться очень большим. Если в исходных таблицах 20 и 30 тысяч строк, то в результате будет 600 миллионов строк. Даже если в запросе есть инструкция `WHERE`, СУБД может потратить много времени и ресурсов на формирование и фильтрацию ненужных значений.

## INNER JOIN


#### **1. Что такое INNER JOIN?**

- INNER JOIN (внутреннее соединение) — соединяет строки двух таблиц, если они удовлетворяют условию соединения.
- Если в одной из таблиц нет соответствующей строки, то она не попадет в результат.

#### **2. Пример использования**

Допустим, есть таблицы **books** (книги) и **authors** (авторы):

**Таблица books:**

| book_id | book_author_id | title          |
| ------- | -------------- | -------------- |
| 500     | 1              | Евгений Онегин |
| 501     | 2              | Анна Каренина  |
| 502     | 2              | Война и мир    |

**Таблица authors:**

| author_id | author_name  |
| --------- | ------------ |
| 1         | А.С. Пушкин  |
| 2         | Л.Н. Толстой |
| 3         | А.П. Чехов   |

books.book_author_id ссылается на authors.author_id.

#### **3. SQL-запрос с INNER JOIN**

```sql
SELECT
    author_name,
    title
FROM books
INNER JOIN authors
    ON book_author_id = author_id;
```

**Результат:**

| author_name  | title          |
| ------------ | -------------- |
| А.С. Пушкин  | Евгений Онегин |
| Л.Н. Толстой | Анна Каренина  |
| Л.Н. Толстой | Война и мир    |

#### **4. Как работает INNER JOIN?**

- Соединяются только те строки, где **book_author_id** в `books` совпадает с **author_id** в `authors`.
- Если автор не написал ни одной книги или книга не имеет автора в таблице `authors`, они не попадут в результат.
- Если одному автору принадлежат несколько книг, каждая из них включается в итоговый список.

#### **5. Выводы**

- **INNER JOIN** используется для соединения строк из двух таблиц по заданному условию.
- В результат попадают **только те строки, которые нашли соответствие**.
- Если нет совпадений, строка не будет включена в итоговый результат.

*Date: 10.03.2025*


## Псевдонимы (aliases)

Штука нужная для работы с большим количеством информации, ведь легко запутаться как нам так и СУБД. И чтоб было проще придумали псевдонимы.

### Неоднозначность запроса и способы его исправления

Можно столкнуться с неоднозначными вопросами и тогда сама СУБД выдаст нам ошибку. 

Припер: 
```sql
SELECT
    name,
    name -- непонятно, откуда какой столбец надо взять
FROM employees
INNER JOIN departments ON
    department_id = department_id; -- непонятно, откуда какой столбец надо взять
```

Получим ошибку `ERROR: ОШИБКА: неоднозначная ссылка на столбец "department_id"`

Вот как это исправлять и не натыкаться на такие ошибки.

### Имя таблицы перед именем столбца

Мы можем добавить имя таблицы перед именем столбца во всех местах, где есть неоднозначность:

```sql
SELECT
    employees.name,
    departments.name -- добавили имена таблиц
FROM employees
INNER JOIN departments ON
    employees.department_id = departments.department_id;
```


### Псевдонимы для таблиц

Вместо имени таблицы можно использовать собственный псевдоним:

```sql
SELECT
    emp.name,
    dep.name
FROM employees AS emp -- объявили псевдоним для employees
INNER JOIN departments AS dep ON -- объявили псевдоним для departments
    emp.department_id = dep.department_id;
```

Короткие псевдонимы таблиц также делают запрос более лаконичным и простым для чтения.

### Псевдонимы для столбцов

**Псевдонимы для столбцов** используются в SQL для присвоения понятных имен столбцам результата запроса. Они объявляются в секции `SELECT` с помощью ключевого слова `AS`.

**Преимущества псевдонимов:**

1. **Упрощение чтения результата** – избегают неинформативных имен, которые СУБД может назначить по-разному.
2. **Использование в `GROUP BY` и `ORDER BY`** – удобно для вычисляемых столбцов, сокращая дублирование кода.

**Пример использования:**  
Выведем названия отделов в верхнем регистре и отсортируем по ним:

```sql
SELECT
    emp.name AS employee,
    UPPER(dep.name) AS department_upcase
FROM employees AS emp
INNER JOIN departments AS dep
    ON emp.department_id = dep.department_id
ORDER BY department_upcase;
```

**Без псевдонима** пришлось бы повторять `UPPER(dep.name)` в `ORDER BY`.

## INNER JOIN и WHERE

INNER JOIN** используется для соединения таблиц, а **WHERE** — для фильтрации данных. Их совместное использование позволяет получать только нужные строки из связанных таблиц.

#### **Пример**

Таблица `authors` содержит авторов и их страны, а `books` — книги и их язык издания.

**Задача:** Получить список книг, изданных на русском языке, но написанных иностранными авторами.

```sql
SELECT
    authors.author_name,
    books.title
FROM books
INNER JOIN authors
    ON books.author_id = authors.author_id
WHERE
    books.language = 'Russian'
    AND authors.origin != 'Russia';
```

🔹 **Логика выполнения запроса:**

1. **INNER JOIN** связывает книги с их авторами.
2. **WHERE** фильтрует строки:
    - Книги должны быть на русском языке.
    - Автор не должен быть из России.
3. Отбираются только нужные столбцы (`author_name`, `title`).

**Вывод:**  
Объединяя `INNER JOIN` и `WHERE`, можно формировать точные запросы, извлекая только релевантные данные.


### **INNER JOIN и GROUP BY**

**INNER JOIN** связывает таблицы, а **GROUP BY** позволяет агрегировать данные. Их совместное использование помогает составлять **сводные отчёты**.

#### **Пример**

Есть таблицы:

- **departments** (отделы компании)
- **employees** (сотрудники, их зарплаты и отделы)

**Задача:** Посчитать количество сотрудников и суммарную зарплату в каждом отделе.

```sql
SELECT
    dep.name AS department, -- название отдела
    COUNT(emp.employee_id) AS employees_count, -- количество сотрудников
    SUM(emp.salary) AS total_salary -- суммарная зарплата
FROM departments AS dep
INNER JOIN employees AS emp
    ON dep.department_id = emp.department_id -- соединяем таблицы
GROUP BY dep.name; -- группировка по отделам
```

🔹 **Логика выполнения запроса:**

1. `INNER JOIN` связывает сотрудников с их отделами.
2. `GROUP BY` группирует строки по названию отдела.
3. `COUNT()` и `SUM()` считают число сотрудников и общую зарплату в группе.

**Ограничения `GROUP BY`:**

- В `SELECT` могут быть **только** поля из `GROUP BY` или агрегатные функции (`SUM()`, `COUNT()`, `MAX()`, и т. д.).

**Вывод:**  
Использование `INNER JOIN` с `GROUP BY` позволяет агрегировать данные из нескольких таблиц, расширяя возможности группировки.


## **LEFT JOIN и RIGHT JOIN**

**LEFT JOIN** и **RIGHT JOIN** используются, когда нужно включить **все строки из одной таблицы**, даже если у них нет соответствий во второй таблице.

### **Сравнение INNER JOIN и LEFT JOIN**

- **INNER JOIN** включает только строки, где есть совпадения в обеих таблицах.
- **LEFT JOIN** включает **все строки из левой таблицы**, а для тех, у кого нет пары, подставляет `NULL`.

#### **Пример:**

```sql
SELECT
    dep.name AS department,
    emp.name AS employee
FROM departments AS dep
LEFT JOIN employees AS emp 
    ON dep.department_id = emp.department_id;
```

📌 Включает все отделы, даже если там нет сотрудников (`NULL`).

---

### **Группировка и LEFT JOIN**

Если посчитать число сотрудников в отделах:

```sql
SELECT
    dep.name AS department,
    COUNT(emp.employee_id) AS employees_count
FROM departments AS dep
LEFT JOIN employees AS emp 
    ON dep.department_id = emp.department_id
GROUP BY dep.name;
```

📌 **Отделы без сотрудников тоже попадут в результат с `0`.**

---

### **RIGHT JOIN**

- Работает аналогично **LEFT JOIN**, но включает **все строки из правой таблицы**.
- **Эквивалент** `LEFT JOIN`, если поменять таблицы местами:

```sql
SELECT
    dep.name AS department,
    COUNT(emp.employee_id) AS employees_count
FROM employees AS emp
RIGHT JOIN departments AS dep 
    ON dep.department_id = emp.department_id
GROUP BY dep.name;
```

---

### **Выводы**

- **LEFT JOIN** – сохраняет **все строки из левой таблицы**.
- **RIGHT JOIN** – сохраняет **все строки из правой таблицы**.
- Для перевода `LEFT JOIN` в `RIGHT JOIN` – **меняем местами таблицы**.

*Date 11.03.2025*

## ANTI JOIN (левое соединение с NULL)

Если мы ходим найти в соединении таблиц все строки без пары, то мы можем использовать прием ANTI JOIN (Это не инструкция в sql, а скорее способ). Делается это с помощью `LEFT JOIN` or `RIGTH JOIN`.

Делается это просто. нужно указать чтоб после LEFT\RIGHT JOIN  он показывать только столбики с нулом

пример:
```sql
SELECT cus.customer_name -- убрали столбец order_id, он все равно не нужен
FROM customers AS cus
LEFT JOIN orders AS ord
    ON
        cus.customer_id = ord.customer_id
WHERE ord.order_id IS NULL -- отбираем только покупателей без заказа
```

## FULL JOIN (полное соединение)

Результат такого соединение имеет все строки из двух таблиц.

- Все строки удовлетворяющие условие соединяются как в INNER JOIN
- Все строки без пары из первой таблицы 
- Все строки без пары из второй таблицы

