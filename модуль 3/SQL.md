**SQL** (Structured Query Language) — это язык программирования, предназначенный для работы с реляционными базами данных. Он используется для создания, модификации и управления данными в этих базах. SQL позволяет выполнять различные операции:

- **Создание и изменение таблиц**: Создание новых таблиц, добавление, изменение и удаление данных.
- **Запросы**: Выборка данных из одной или нескольких таблиц по заданным условиям.
- **Управление доступом**: Установка прав доступа к данным для пользователей.

SQL широко используется в различных областях, таких как бизнес, финансы, наука, веб-разработка и анализ данных. Он является стандартным инструментом для работы с реляционными базами данных и поддерживается большинством систем управления базами данных (СУБД).

### Основные особенности SQL:

- **Декларативный язык**: SQL описывает, что нужно сделать с данными, а не как это сделать.
- **Реляционные базы данных**: Данные хранятся в виде таблиц со строками и столбцами.
- **Удобочитаемый синтаксис**: SQL-запросы часто напоминают английские предложения, что делает их относительно простыми для понимания и использования.

### Применение SQL:

- **Анализ данных**: SQL используется для извлечения и анализа данных.
- **Веб-разработка**: Для создания динамического контента и управления учетными записями пользователей.
- **Управление базами данных**: Создание, управление и оптимизация баз данных.

## Команды

Запустить стандартного пользователя для подключения к СУБД
```bash
sudo -i -u postgres 
```

Дальше нужно запустить саму программу командой psql
```bash
psql
```

Чтоб сделать выборку данных используется следующая команда
```SQL
SELECT * FROM users;
```
\* -  обозначает все поля, а если нужны конкретные поля то их нужно указать через запятую. А после слова FROM указываются таблицы.

Счетчик который автоматически считает и присваивает значения новым данным ++i
```SQL
PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
```

### Фильтрация данных 


1. **Оператор WHERE**:
   - Используется для фильтрации данных в запросах SELECT.
   - Позволяет выбирать строки, удовлетворяющие определенному условию.
   - Пример: `SELECT * FROM users WHERE id > 60;` — выбирает пользователей с `id` больше 60.

2. **Операторы сравнения**:
   - `=` — равно
   - `!=` — не равно
   - `>` — больше
   - `<` — меньше
   - `>=` — больше или равно
   - `<=` — меньше или равно

3. **Типы данных и оформление**:
   - Числа: используются без кавычек.
   - Текст: должен быть заключен в одинарные кавычки (например, `first_name = 'Johan'`).
   - Даты: также заключаются в одинарные кавычки (например, `created_at > '2022-06-14'`).

4. **Результат запроса**:
   - Всегда возвращает таблицу, даже если найдена одна запись или ничего не найдено.

5. **Примеры запросов**:
   - Выбор пользователя с `id = 1`: `SELECT * FROM users WHERE id = 1;`
   - Выбор всех пользователей, кроме `id = 3`: `SELECT * FROM users WHERE id != 3;`
   - Выбор курсов, созданных после 14 июня 2022: `SELECT name, created_at FROM courses WHERE created_at > '2022-06-14';`

### NULL

**NULL**:
   - Специальное значение, обозначающее отсутствие данных в ячейке таблицы.
   - Используется для незаполненных полей (например, необязательные данные, такие как дата рождения).

 **Операторы для работы с NULL**:
   - Для проверки на NULL используйте `IS NULL` и `IS NOT NULL`.
   - Стандартные операторы сравнения (`=`, `!=`, `>`, `<` и т.д.) **не работают** с NULL.

### Фильтрация строк 

Используют `LIKE` потом кусок текста и знак `%` который обозначает любое количество символов. Лайк чувствителен к регистру. Если нам все ровно на регистр, то используем `ILIKE` ^^

### Регулярные выражения — Основы SQL

1. **Регулярные выражения (RegEx)**:
   - Используются для точного поиска строк по шаблону.
   - В SQL применяется оператор `SIMILAR TO` для работы с регулярными выражениями.

2. **Основные шаблоны**:
   - `[AB]%` — строки, начинающиеся с 'A' или 'B'.
   - `%[a-z]` — строки, заканчивающиеся на любую букву.
   - `%[0-9]` — строки, заканчивающиеся на цифру.
   - `%[а-я]%` — строки, содержащие русские буквы.

3. **Символы в регулярных выражениях**:
   - `%` — любое количество любых символов.
   - `[]` — перечисление допустимых символов (например, `[AB]`).
   - `-` — диапазон символов (например, `[a-z]` или `[0-9]`).
   - `_` — ровно один любой символ.

### Логические операторы
OR (ИЛИ): Возвращает True, если выполняется хотя бы одно из условий.
AND (И): Возвращает True, только если выполняются оба условия.


### Фильтрация данных по диапазону — Основы SQL

1. **Оператор `BETWEEN`**:
   - Используется для фильтрации данных по диапазону значений.
   - Удобная альтернатива комбинации операторов `>=` и `<=`.
   - Включает в диапазон крайние значения.

2. **Примеры запросов**:
   - Фильтрация по дате:  
     ```sql
     SELECT * FROM users
     WHERE birthday BETWEEN '2022-01-01' AND '2022-02-01';
     ```
     Выбирает пользователей с датой рождения от 1 января до 1 февраля 2022 года (включительно).
   
   - Эквивалентный запрос с использованием `>=` и `<=`:  
     ```sql
     SELECT * FROM users
     WHERE birthday >= '2022-01-01' AND birthday <= '2022-02-01';
     ```

3. **Исключение диапазона**:
   - Используйте `NOT BETWEEN` для исключения значений из диапазона:  
     ```sql
     SELECT * FROM users
     WHERE birthday NOT BETWEEN '2022-01-01' AND '2022-02-01';
     ```
     Выбирает пользователей с датой рождения до 1 января или после 1 февраля 2022 года.

4. **Применение к числам**:
   - `BETWEEN` можно использовать и для числовых значений:  
     ```sql
     SELECT * FROM users
     WHERE id BETWEEN 15 AND 23;
     ```
     Выбирает пользователей с `id` от 15 до 23 (включительно).

5. **Выводы**:
   - `BETWEEN` упрощает запросы, улучшает читаемость и снижает вероятность ошибок.
   - Включает крайние значения диапазона.
   - Для исключения диапазона используйте `NOT BETWEEN`.

###  Как искать поля, соответствующие значению из набора? 

Все просто используй `IN` или `NOT IN`. 
```SQL
SELECT
    id,
    first_name,
    last_name
FROM users
WHERE id IN (1, 2, 5);
```

### Сортировка данных 

Таблицы по умолчанию сортируются как им вздумается и это не всегда совпадает с нашими требованиями, чтоб отсортировать данные мы используем `ORDER BY`.

пример:
```SQL
SELECT
    id,
    username,
    created_at
FROM users ORDER BY username;
```

База данных знает как сортировать строки числа и даты. 

#### как же управлять порядком сортировки ? 

- Прямой порядок: если ничего не указано, то `ORDER BY` отсортирует все в прямом порядке, как если бы было указано `ASC`, он подставляется автоматически, если ничего не указано 
```SQL
SELECT
    id,
    username,
    created_at
FROM users ORDER BY created_at ASC;
-- То же самое, что и
SELECT
    id,
    username,
    created_at
FROM users ORDER BY created_at;
```
- Обратный порядок сортировки: что бы выполнить обратную сортировку укажем `DESC`.
- Сортировка по нескольким полям: просто перечисляем поля через запятую и для каждого поля указываем вид сортировки. (помни, что по умолчанию ставиться `ASC`)

#### что делать с Null значениями? 

СУБД сама решает куда засунуть нулл значения, но если нам нужно их нахождение конкретно, то указываем 
- `NULLS FIRST`
- `NULLS LAST`

### Ограничение выборки 

Таблички обычно большие и для того, что бы получить данные, которые реально обработать, придумали `LIMIT`. 

Пример:
```SQL
SELECT
    id,
    username,
    email
FROM users LIMIT 10;
```

Лимит всегда используется с сортировкой, ведь мы не знаем какие 10 записей нам выдаст СУБД без сортировки. Вот пример использования с сортировкой:
```SQL
SELECT
	id,
	username,
	email
FROM users ORDER BY id LIMIT 10;
```

#### Как показать все данные по выборкам ?

Для этого нам понадобится *плагинация*. Это механизм, который позволяет перемещаться по страницам.

Чтобы реализовать пагинацию, одного `LIMIT` недостаточно. Еще понадобится смещение `OFFSET`:
```SQL
SELECT
    id,
    username,
    email
FROM users ORDER BY id LIMIT 10 OFFSET 10;
```

### Уникальные строки

В языке SQL существует специальный оператор `DISTINCT`. Он удаляет повторяющиеся строки и оставляет только уникальные. Запрос с этим оператором будет выглядеть так: 
```SQL
SELECT DISTINCT course_id FROM course_memders ORDER BY course_id;
```

Таким образом, чтобы исключить повторяющиеся строки, нужно после оператора `SELECT` указать `DISTINCT` и перечислить все нужные столбцы.

Если мы добавим в наш запрос еще одно поле `user_id`, то это изменит результат запроса. В эту выборку попадут строки с уникальным сочетанием курса и слушателя.

По отдельности курсы и слушатели могут повторяться, но их сочетание будет уникальным

Так же есть оператор `DISTINCT ON` в него в скобки можно указать поле уникальность которого будет проверяться. Так же туда можно засунуть и несколько значений.

#### что такая сортировки и дискрит он

В `ORDER BY` важно первым указывать те поля, которые указаны в скобках в дисккрит он.



## Агрегатные функции !

В SQL так же есть функции! Важно помнить, что они работают не со всех таблицей, а с результатом запроса.

Привет 
```SQL
SELECT COUNT(*) FROM users; 
```

в скобках указываются аргументы и вернет такой запрос результат функции.
Вот базовые функции из лекции хекслета:

- `COUNT` - позволяет подсчитать количество строк
    
- `SUM` - позволяет найти сумму чисел
    
- `AVG` - позволяет подсчитать среднее арифметическое
    
- `MAX` - возвращает максимальное значение численного поля или последнюю строку по алфавиту
    
- `MIN` - возвращает минимальное значение численного поля или первую строку по алфавиту


### 🔹 **Что такое GROUP BY и зачем он нужен?**

Оператор **`GROUP BY`** в SQL нужен для того, чтобы **группировать одинаковые значения в колонке** и выполнять над ними **агрегатные функции** (например, `COUNT`, `SUM`, `AVG`, `MAX`, `MIN`).

Простой пример:  
Допустим, у тебя есть таблица `course_members`, где хранятся записи о том, какие пользователи записаны на курсы.

|id|user_id|course_id|
|---|---|---|
|1|2|101|
|2|3|102|
|3|2|103|
|4|5|104|
|5|5|105|
|6|5|106|

**Задача**: посчитать, сколько курсов посещает каждый пользователь.

Обычный `SELECT` тут не поможет, потому что в таблице есть **повторяющиеся `user_id`**, а нам нужно для каждого пользователя посчитать общее количество курсов.

### 🔹 **Как работает GROUP BY?**

Мы используем `GROUP BY`, чтобы сгруппировать записи по `user_id` и посчитать количество курсов (`COUNT(*)`):

```sql
SELECT
    user_id,
    COUNT(*) AS courses_count
FROM course_members
GROUP BY user_id
ORDER BY user_id;
```

**Что тут происходит?**

1. **`GROUP BY user_id`** – SQL группирует все записи, где `user_id` совпадает, и рассматривает их как одну "группу".
2. **`COUNT(*) AS courses_count`** – считает, сколько строк (то есть курсов) есть в каждой группе.
3. **`ORDER BY user_id`** – сортирует результат по `user_id`.

**Результат запроса:**

|user_id|courses_count|
|---|---|
|2|2|
|3|1|
|5|3|

**Вывод**:

- `user_id = 2` записан на **2 курса**.
- `user_id = 3` записан на **1 курс**.
- `user_id = 5` записан на **3 курса**.

### 🔹 **Почему без GROUP BY не работает?**

Если ты попробуешь сделать так:

```sql
SELECT user_id, COUNT(*)
FROM course_members;
```

СУБД **выдаст ошибку**, потому что она не знает, как считать `COUNT(*)`, если `user_id` разный.

### 🔹 **Ошибка: что делать, если запрос с GROUP BY не работает?**

Допустим, ты пишешь такой запрос:

```sql
SELECT
    user_id,
    created_at,
    COUNT(*)
FROM course_members
GROUP BY user_id;
```

❌ **Ошибка**: `column "course_members.created_at" must appear in the GROUP BY clause or be used in an aggregate function`

💡 **Почему?**

- Ты группируешь по `user_id`, но при этом выводишь `created_at`, а у одного `user_id` может быть **несколько разных дат**.
- SQL не знает, какую именно дату из группы показывать.

✅ **Как исправить?**  
Ты можешь применить агрегатную функцию, например, `MAX(created_at)`, чтобы взять **самую позднюю дату**:

```sql
SELECT
    user_id,
    COUNT(*) AS courses_count,
    MAX(created_at) AS last_registration
FROM course_members
GROUP BY user_id;
```

Теперь SQL понимает, что ему делать:

- `COUNT(*)` считает количество курсов.
- `MAX(created_at)` берёт **самую позднюю дату**, когда пользователь записался на курс.

---

### **Итог**

- `GROUP BY` **объединяет одинаковые значения в группы**.
- В `SELECT` после `GROUP BY` можно:
    - Либо использовать **агрегатные функции** (`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`).
    - Либо **выводить только те столбцы, по которым идёт группировка**.
- Если возникает ошибка "column must appear in GROUP BY", значит, тебе нужно либо добавить этот столбец в `GROUP BY`, либо применить к нему агрегатную функцию.


### **Фильтрация с помощью HAVING**

#### **1️⃣ Ключевое слово HAVING**

- **HAVING** используется для фильтрации **уже сгруппированных данных**.
    
- Позволяет **задавать условия для агрегатных функций** (`SUM`, `COUNT`, `AVG`, `MAX`, `MIN`).
    
- Пример: найти пользователей, которые провели **менее 30 минут** на платформе:
    
    ```sql
    SELECT user_id, SUM(spent_minutes)
    FROM course_reviews
    GROUP BY user_id
    HAVING SUM(spent_minutes) < 30
    ORDER BY user_id;
    ```
    

#### **2️⃣ Разница между HAVING и WHERE**

|**WHERE**|**HAVING**|
|---|---|
|Фильтрует **до** группировки|Фильтрует **после** группировки|
|Применяется к **отдельным строкам**|Применяется к **группам строк**|
|Нельзя использовать с агрегатными функциями|Работает с агрегатными функциями|

Пример комбинированного запроса:

```sql
SELECT user_id, SUM(spent_minutes)
FROM course_reviews
WHERE user_id <= 40  -- Фильтрация до группировки
GROUP BY user_id
HAVING SUM(spent_minutes) < 30  -- Фильтрация после группировки
ORDER BY user_id;
```

#### **3️⃣ Выводы**

- **WHERE** применяется перед `GROUP BY`, **HAVING** — после.
- Для фильтрации по агрегатным функциям **нужно использовать HAVING**.
- Комбинация **WHERE + HAVING** помогает **оптимизировать запросы** (сначала фильтруем строки, потом считаем агрегаты).

### **Вставка и модификация данных в SQL**

#### **📌 1. Добавление данных – `INSERT`**

**Формат запроса:**

```sql
INSERT INTO table_name (column1, column2, column3)  
VALUES (value1, value2, value3);
```

- Перечисляем **названия столбцов** и **значения** в том же порядке.
- Можно добавить **несколько строк** за один раз:

```sql
INSERT INTO users (username, email)  
VALUES ('AgentJ', 'wsmith09@gmail.com'),  
       ('MrBatman', 'benaff@gmail.com');
```

- Дубликаты **не допускаются** (например, `id` должен быть уникальным).

---

#### **📌 2. Обновление данных – `UPDATE`**

**Формат запроса:**

```sql
UPDATE table_name  
SET column1 = value1, column2 = value2  
WHERE condition;
```

- `SET` указывает, какие данные обновить.
- `WHERE` фильтрует записи, которые нужно обновить.
- **Важно:** Без `WHERE` обновит **все записи** в таблице!

**Пример:**

```sql
UPDATE users  
SET username = 'SuperAgent007'  
WHERE email = 'agent007@yahoo.com';
```

📌 **Операции сравнения:**

- `>` , `<`, `>=`, `<=`, `!=` (не равно).
- **Пример:** Обновить имя всем, кто родился после 1970 года:

```sql
UPDATE users SET first_name = 'John' WHERE birthday > '1970-01-01';
```

📌 **Логические операции (`AND`, `OR`):**

```sql
UPDATE users  
SET email = 'johndoe@yahoo.com'  
WHERE first_name = 'John' AND last_name = 'Doe';
```

---

#### **📌 3. Удаление данных – `DELETE`**

**Формат запроса:**

```sql
DELETE FROM table_name WHERE condition;
```

- **Обязательно** указывать `WHERE`, иначе удалит **всё**!
- **Пример:** Удалить пользователя по `username`:

```sql
DELETE FROM users WHERE username = 'secretagent';
```

📌 **Удаление по нескольким условиям:**

```sql
DELETE FROM users  
WHERE (birthday BETWEEN '1968-01-01' AND '2000-01-01')  
   OR (id = 100);
```

- `BETWEEN` – диапазон значений (включительно).
- `OR` – одно из условий должно быть истинным.

---

#### **📌 4. Полная очистка таблицы – `TRUNCATE`**

```sql
TRUNCATE table_name;
```

- **Удаляет все данные из таблицы мгновенно.**
- **Нельзя задать `WHERE`** (очистит всё).

📌 **Пример:**

```sql
TRUNCATE users;
```

---

### **🔹 Итоговые выводы:**

✅ `INSERT` – добавляет данные.  
✅ `UPDATE` – изменяет существующие записи (с `WHERE` или без).  
✅ `DELETE` – удаляет **отдельные строки** (`WHERE` обязателен).  
✅ `TRUNCATE` – удаляет **все записи** в таблице, но **быстрее, чем `DELETE`**.

⚠ **Осторожно с `UPDATE` и `DELETE` без `WHERE` – можно потерять все данные!**


### **Основные ограничения полей в SQL**

#### **🔹 1. Ограничение `UNIQUE` (уникальность значений)**

- **Гарантирует, что значения в колонке не повторяются**.
- Применяется к **одному или нескольким столбцам**.
- **Ошибка при попытке вставить дублирующее значение**.

✅ **Пример:**

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    email VARCHAR(255) UNIQUE
);
```

❌ **Ошибка при попытке вставить повторный email**.

---

#### **🔹 2. Ограничение `NOT NULL` (запрещает `NULL`-значения)**

- **Запрещает `NULL` в указанной колонке**.
- **Гарантирует, что поле всегда будет заполнено**.

✅ **Пример:**

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);
```

❌ **Ошибка при попытке вставить `NULL` в `username`**.

---

#### **🔹 3. Несколько ограничений одновременно**

- Можно **объединять `UNIQUE` и `NOT NULL`** в одной колонке.

✅ **Пример:**

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL
);
```

✔ `username` и `email` должны быть **уникальными и не пустыми**.

---

### **📌 Выводы**

✅ `UNIQUE` – гарантирует **уникальность** значений.  
✅ `NOT NULL` – **запрещает пустые (`NULL`) значения**.  
✅ Можно **использовать оба ограничения вместе** для надежности данных.

⚡ **Используй `UNIQUE` и `NOT NULL`, чтобы защитить базу данных от ошибок!** 🚀


### **`ALTER TABLE` – изменение структуры таблицы**

`ALTER TABLE` – команда для изменения структуры таблицы. Позволяет:

1. **Добавлять колонки (`ADD COLUMN`)**
2. **Переименовывать колонки (`RENAME COLUMN`)**
3. **Удалять колонки (`DROP COLUMN`)**
4. **Обновлять параметры колонок (`ALTER COLUMN`)**

---

### **🔹 1. Добавление колонки (`ADD COLUMN`)**

```sql
ALTER TABLE users ADD COLUMN birthday DATE;
```

✔ Добавляет новую колонку `birthday` с типом `DATE`.

---

### **🔹 2. Переименование колонки (`RENAME COLUMN`)**

```sql
ALTER TABLE users RENAME COLUMN name TO first_name;
```

✔ Меняет имя `name` на `first_name`.

---

### **🔹 3. Удаление колонки (`DROP COLUMN`)**

```sql
ALTER TABLE users DROP COLUMN age;
```

✔ Полностью удаляет колонку `age`.

---

### **🔹 4. Обновление колонки (`ALTER COLUMN`)**

✔ **Изменение типа данных:**

```sql
ALTER TABLE courses ALTER COLUMN created_at SET DATA TYPE DATE;
```

✔ **Снятие ограничения `NOT NULL`:**

```sql
ALTER TABLE courses ALTER COLUMN name DROP NOT NULL;
```

✔ **Добавление `NOT NULL`:**

```sql
ALTER TABLE courses ALTER COLUMN name SET NOT NULL;
```

✔ **Добавление `UNIQUE`:**

```sql
ALTER TABLE courses ADD UNIQUE (name);
```

---

### **📌 Выводы**

✅ `ADD COLUMN` – добавляет новые колонки.  
✅ `RENAME COLUMN` – меняет имя колонки.  
✅ `DROP COLUMN` – удаляет колонку (⚠ осторожно, нельзя восстановить!).  
✅ `ALTER COLUMN` – изменяет тип, добавляет/убирает ограничения.

⚠ **Удаление и обновление колонок может вызвать ошибки в работающей базе!**

📌 **Используй `ALTER TABLE` с осторожностью!** 🚀



### **Транзакционность в SQL**

#### **🔹 1. Что такое транзакция?**

Транзакция – это **группа SQL-запросов**, выполняемых как **единое целое**. Если один из запросов не выполняется, **все изменения откатываются**.

📌 **Команды транзакции:**

```sql
BEGIN;       -- Начало транзакции
UPDATE ...;  -- Изменения в базе
COMMIT;      -- Подтверждение изменений
ROLLBACK;    -- Откат транзакции (если нужно)
```

---

#### **🔹 2. Пример транзакции (перевод денег)**

```sql
BEGIN;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
COMMIT;
```

✔ **Если ошибка случится в любом шаге – изменения не сохранятся**.

**Откатить транзакцию вручную:**

```sql
BEGIN;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
ROLLBACK;  -- Отмена изменений
```

---

#### **🔹 3. ACID – 4 требования к надежной транзакции**

1️⃣ **Атомарность (`Atomicity`)** – транзакция **либо выполняется полностью, либо не выполняется вообще**.  
2️⃣ **Согласованность (`Consistency`)** – данные **остаются в корректном состоянии** после завершения транзакции.  
3️⃣ **Изолированность (`Isolation`)** – параллельные транзакции **не мешают друг другу**.  
4️⃣ **Устойчивость (`Durability`)** – завершенные изменения **не пропадают даже после сбоя системы**.

---

### **📌 Выводы**

✅ Транзакции гарантируют **надежное выполнение операций** в БД.  
✅ **`COMMIT`** – сохраняет изменения, **`ROLLBACK`** – отменяет их.  
✅ ACID-правила делают транзакции **безопасными и предсказуемыми**.

⚡ **Используй транзакции при важных изменениях, чтобы избежать потери данных!** 🚀